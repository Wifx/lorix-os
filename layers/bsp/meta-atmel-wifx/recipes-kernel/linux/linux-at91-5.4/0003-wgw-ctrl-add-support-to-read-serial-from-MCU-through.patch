From e72814e24d5e94c8e3f69d82997a5b56fcb5265d Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Fri, 6 Aug 2021 16:28:36 +0200
Subject: [PATCH 3/3] wgw-ctrl: add support to read serial from MCU through i2c

Signed-off-by: Yannick Lanz <yannick.lanz@wifx.net>
---
 drivers/mfd/wgw-ctrl-core.c      | 77 ++++++++++++++++++++++++++++++++
 include/linux/mfd/wgw-ctrl/reg.h |  1 +
 2 files changed, 78 insertions(+)

diff --git a/drivers/mfd/wgw-ctrl-core.c b/drivers/mfd/wgw-ctrl-core.c
index feec20c95274..18674fce7657 100644
--- a/drivers/mfd/wgw-ctrl-core.c
+++ b/drivers/mfd/wgw-ctrl-core.c
@@ -52,10 +52,17 @@ struct version {
 	u16 revision;
 };
 
+#define HW_SN_MAX_SIZE 15
+struct serial {
+	int status;
+	char data[HW_SN_MAX_SIZE + 1];
+};
+
 struct hw_info {
 	struct version version;
 	u8 type;
 	u8 subtype;
+	struct serial serial;
 };
 
 #define APP_COMMIT_HASH_MAX_SIZE 15
@@ -94,6 +101,47 @@ static int boot_state_clr(struct wgw_ctrl_dev *wgw)
 	return ret;
 }
 
+static int serial_get(struct wgw_ctrl_dev *wgw, char *dest, size_t maxlen,
+		      int *status)
+{
+	int ret;
+	size_t len;
+	// contains serial status, serial and termination character
+	char buffer[1 + HW_SN_MAX_SIZE + 1];
+
+	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_SN, buffer,
+				 sizeof(buffer))) < 0) {
+		dev_err(wgw->dev, "failed to read from device\n");
+		return ret;
+	}
+
+	*status = (int)buffer[0];
+	if (!*status) {
+		// serial is not set
+		return 0;
+	} else if (*status < 0) {
+		// error on MCU side
+		dev_err(wgw->dev,
+			"get serial error: mcu returned an error (%d)\n",
+			*status);
+		return -EIO;
+	}
+
+	if ((len = strnlen(&buffer[1], HW_SN_MAX_SIZE + 1)) ==
+	    HW_SN_MAX_SIZE + 1) {
+		dev_err(wgw->dev, "get serial error: serial too long\n");
+		return -EINVAL;
+	}
+	if (!len) {
+		dev_err(wgw->dev,
+			"get serial error: cannot get serial (len = 0)\n");
+		return -EINVAL;
+	}
+
+	strncpy(dest, &buffer[1], maxlen);
+	return len;
+}
+
 static ssize_t dev_version_show(struct device *dev,
 				struct device_attribute *attr, char *buf)
 {
@@ -202,6 +250,20 @@ static ssize_t product_type_show(struct device *dev,
 	}
 }
 
+static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct wgw_ctrl_dev *wgw = dev_get_drvdata(dev);
+	struct product_info *info = wgw->product_info;
+	if (!info->hw_info.serial.status) {
+		return sprintf(buf, "%s\n", "not set");
+	} else if (info->hw_info.serial.status < 0) {
+		return sprintf(buf, "%s\n", "error");
+	} else {
+		return sprintf(buf, "%s\n", info->hw_info.serial.data);
+	}
+}
+
 static ssize_t memory_ram_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
@@ -217,6 +279,7 @@ static ssize_t memory_nand_show(struct device *dev,
 static DEVICE_ATTR(dev_version, S_IRUGO, dev_version_show, NULL);
 static DEVICE_ATTR(model, S_IRUGO, product_model_show, NULL);
 static DEVICE_ATTR(type, S_IRUGO, product_type_show, NULL);
+static DEVICE_ATTR(serial, S_IRUGO, serial_show, NULL);
 static DEVICE_ATTR(boot_state,
 		   (S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH),
 		   boot_state_show, boot_state_store);
@@ -230,6 +293,7 @@ static const struct attribute *machine_attrs[] = {
 	&dev_attr_dev_version.attr,
 	&dev_attr_model.attr,
 	&dev_attr_type.attr,
+	&dev_attr_serial.attr,
 	&dev_attr_boot_state.attr,
 	&dev_attr_fw_version.attr,
 	&dev_attr_fw_version_hash.attr,
@@ -271,6 +335,12 @@ static int populate_info(struct wgw_ctrl_dev *wgw)
 		dev_err(dev, "failed to read hardware info (%d)\n", ret);
 		return ret;
 	}
+	ret = serial_get(wgw, (u8 *)info->hw_info.serial.data,
+			 sizeof(info->hw_info.serial.data),
+			 &info->hw_info.serial.status);
+	if (ret < 0) {
+		dev_err(dev, "failed to read serial (%d)\n", ret);
+	}
 	ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO1,
 			    (u8 *)&info->fw_info.version,
 			    sizeof(struct version));
@@ -331,6 +401,13 @@ static int verify_display_info(struct wgw_ctrl_dev *wgw)
 		dev_err(dev, "Subtype not detected or unknown\n");
 		return -ENODEV;
 	}
+	if (!info->hw_info.serial.status) {
+		dev_warn(dev, "  Serial: not set\n");
+	} else if (info->hw_info.serial.status < 0) {
+		dev_err(dev, "  Serial: error\n");
+	} else {
+		dev_info(dev, "  Serial: %s\n", info->hw_info.serial.data);
+	}
 
 	if (info->hw_info.version.revision > 0) {
 		dev_info(dev, "  HW ver: %d.%d%c\n",
diff --git a/include/linux/mfd/wgw-ctrl/reg.h b/include/linux/mfd/wgw-ctrl/reg.h
index 5118632dc48e..58f868ad10ce 100644
--- a/include/linux/mfd/wgw-ctrl/reg.h
+++ b/include/linux/mfd/wgw-ctrl/reg.h
@@ -23,6 +23,7 @@
 #define WGW_CTRL_REG_FW_INFO2 0x21
 #define WGW_CTRL_REG_FW_INFO3 0x22
 #define WGW_CTRL_REG_FW_INFO4 0x23
+#define WGW_CTRL_REG_SN 0x24
 #define WGW_CTRL_REG_LED_START 0x60
 #define WGW_CTRL_REG_LAST_RESET_STATE 0x70
 #define WGW_CTRL_REG_USB_MODE_POWER 0x80
-- 
2.25.1

