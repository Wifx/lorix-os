From cf70c4b581bfcdcebe9723ba272c8ee0078d8908 Mon Sep 17 00:00:00 2001
From: OpenEmbedded <oe.patch@oe>
Date: Mon, 18 Oct 2021 21:29:45 +0200
Subject: [PATCH 11/11] wgw-ctrl: update to comm protocol version 2 with SMBus
 and PEC support

Signed-off-by: OpenEmbedded <oe.patch@oe>
---
 drivers/leds/leds-wgw-ctrl.c      |   5 +-
 drivers/mfd/wgw-ctrl-core.c       | 480 +++++++++++++++++++++---------
 drivers/mfd/wgw-ctrl-i2c.c        | 119 +++++---
 drivers/mfd/wgw-ctrl-usbc.c       |  13 +-
 include/linux/mfd/wgw-ctrl/core.h |  15 +-
 include/linux/mfd/wgw-ctrl/reg.h  |   9 +-
 6 files changed, 437 insertions(+), 204 deletions(-)

diff --git a/drivers/leds/leds-wgw-ctrl.c b/drivers/leds/leds-wgw-ctrl.c
index 73f62044b039..5b67d1b3d845 100644
--- a/drivers/leds/leds-wgw-ctrl.c
+++ b/drivers/leds/leds-wgw-ctrl.c
@@ -50,9 +50,8 @@ static void wgw_ctrl_led_set_work(struct work_struct *work)
 		container_of(work, struct wgw_ctrl_led, work);
 	struct wgw_ctrl_leds *leds = led->leds;
 	struct wgw_ctrl_dev *mcu = leds->master;
-
-	u8 brightness = led->new_brightness;
-	mcu->write_dev(mcu, WGW_CTRL_REG_LED_START + led->id, &brightness, 1);
+	mcu->write_word(mcu, WGW_CTRL_REG_LED_START + led->id,
+			(u16)led->new_brightness);
 }
 
 static void wgw_ctrl_led_set(struct led_classdev *led_cdev,
diff --git a/drivers/mfd/wgw-ctrl-core.c b/drivers/mfd/wgw-ctrl-core.c
index 11b82742ad88..564084ca0930 100644
--- a/drivers/mfd/wgw-ctrl-core.c
+++ b/drivers/mfd/wgw-ctrl-core.c
@@ -30,11 +30,6 @@
 #include <linux/mfd/wgw-ctrl/core.h>
 #include <linux/mfd/wgw-ctrl/reg.h>
 
-#define PRODUCT_MODEL_WIFX_L1 0x01
-#define PRODUCT_VARIANT_8xx 0x00
-#define PRODUCT_VARIANT_9xx 0x02
-#define PRODUCT_VARIANT_Y_LYNX 0x08
-
 static struct mfd_cell wgw_ctrl_devs[] = {
 	{
 		.name = "wgw-ctrl-led",
@@ -49,59 +44,60 @@ static struct mfd_cell wgw_ctrl_devs[] = {
 enum model {
 	M_LORIX_ONE = 0,
 	M_WIFX_L1 = 1,
+	M_WIFX_Y1 = 2,
 };
 
 enum variant {
-	V_863_870 = 0,
-	V_902_928 = 2,
-	V_Y_Lynx = 8,
-	V_UNKNOWN = 100,
+	V_STANDARD = 0,
+};
+
+enum frequency {
+	F_863_870 = 0,
+	F_902_928 = 2,
 };
+
 static const char *unknown_str = "unknown";
 static const char *undefined_str = "undefined";
 static const char *error_str = "error";
 
-static const char *model_strs[] = { "LORIX One", "Wifx L1",
-				    "Wifx L1 (Y-Lynx)" };
-int model_index(enum model model, enum variant variant)
+static const char *model_strs[] = { "lorix-one", "wifx-l1", "wifx-y1" };
+static const char *model_pretty_strs[] = { "LORIX One", "Wifx L1", "Wifx Y1" };
+int model_index(enum model model)
 {
 	switch (model) {
 	case M_LORIX_ONE:
-		return 0;
 	case M_WIFX_L1:
-		switch (variant) {
-		case V_863_870:
-		case V_902_928:
-			return 1;
-		case V_Y_Lynx:
-			return 2;
-		default:
-			break;
-		}
+	case M_WIFX_Y1:
+		return (int)model;
 	default:
-		break;
+		return -1;
 	}
-	return -1;
 }
 
-const char *model_str(enum model model, enum variant variant)
+const char *model_str(enum model model)
 {
 	int index;
-	if ((index = model_index(model, variant)) < 0) {
+	if ((index = model_index(model)) < 0) {
 		return unknown_str;
 	}
 	return model_strs[index];
 }
 
-static const char *variant_strs[] = { "863-870", "902-928" };
+const char *model_pretty_str(enum model model)
+{
+	int index;
+	if ((index = model_index(model)) < 0) {
+		return unknown_str;
+	}
+	return model_pretty_strs[index];
+}
+
+static const char *variant_strs[] = { "standard" };
 int variant_index(enum variant variant)
 {
 	switch (variant) {
-	case V_863_870:
-	case V_Y_Lynx:
-		return 0;
-	case V_902_928:
-		return 1;
+	case V_STANDARD:
+		return (int)variant;
 	default:
 		return -1;
 	}
@@ -115,6 +111,26 @@ const char *variant_str(enum variant variant)
 	return variant_strs[index];
 }
 
+static const char *frequency_strs[] = { "863-870", "902-928" };
+int frequency_index(enum frequency frequency)
+{
+	switch (frequency) {
+	case F_863_870:
+	case F_902_928:
+		return (int)frequency;
+	default:
+		return -1;
+	}
+}
+const char *frequency_str(enum frequency frequency)
+{
+	int index;
+	if ((index = frequency_index(frequency)) < 0) {
+		return unknown_str;
+	}
+	return frequency_strs[index];
+}
+
 struct version {
 	u16 major;
 	u16 minor;
@@ -123,15 +139,15 @@ struct version {
 
 #define HW_SN_MAX_SIZE 16
 struct serial {
-	int status;
 	char data[HW_SN_MAX_SIZE];
+	int status;
 };
 
 struct hw_info {
 	struct version version;
 	u8 model;
 	u8 variant;
-	struct serial serial;
+	u8 frequency;
 };
 
 #define APP_COMMIT_HASH_MAX_SIZE 16
@@ -142,12 +158,66 @@ struct fw_info {
 	char commit_date[APP_COMMIT_DATE_MAX_SIZE];
 };
 
+#define MEM_SLOT_EMPTY 0x00
+#define MEM_SLOT_SET 0x01
+#define MEM_SLOT_OTP 0x02
+#define MEM_SLOT_SET_OTP (MEM_SLOT_SET | MEM_SLOT_OTP)
+#define MEM_SLOT_STATE_Msk 0x03
+
+struct memory_slot {
+	u8 data[32];
+	u8 length;
+	u8 flags;
+};
+
 struct product_info {
 	struct fw_info fw_info;
 	struct hw_info hw_info;
+	struct serial serial;
 	u8 boot_state;
 };
 
+#define CMD_LTR_STATUS_SUCCESS 0
+#define CMD_LTR_STATUS_BUSY 1
+#define CMD_LTR_STATUS_INVALID_ARG 2
+#define CMD_LTR_STATUS_FAILURE 3
+#define CMD_LTR_STATUS_BAD_CRC 4
+#define CMD_LTR_STATUS_NOT_WRITABLE 5
+#define CMD_LTR_STATUS_PAGE_NOT_ALIGNED 6
+
+static int mcu_get_ltr_status(struct wgw_ctrl_dev *wgw)
+{
+	int ret;
+	u8 status;
+	if ((ret = wgw->read_byte(wgw, WGW_CTRL_REG_CMD_LTR_STATUS, &status)) <
+	    0) {
+		dev_err(wgw->dev,
+			"failed to read LTR command status from device\n");
+		return ret;
+	}
+	return (int)status;
+}
+
+static int mcu_wait_ready(struct wgw_ctrl_dev *wgw)
+{
+	int i, status;
+	for (i = 0; i < 10; i++) {
+		if ((status = mcu_get_ltr_status(wgw)) < 0) {
+			return status;
+		}
+		if (status == CMD_LTR_STATUS_SUCCESS) {
+			return 0;
+		}
+		if (status == CMD_LTR_STATUS_BUSY) {
+			msleep(5);
+			continue;
+		}
+		dev_err(wgw->dev, "LTR command error status: %d\n", status);
+		return -EIO;
+	}
+	return -EBUSY;
+}
+
 static char *hw_version_str(const struct version *version)
 {
 	static char ver_str[10];
@@ -171,8 +241,8 @@ static char *fw_version_str(const struct version *version)
 static int boot_state_fetch(struct wgw_ctrl_dev *wgw, u8 *boot_state)
 {
 	int ret;
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_LAST_RESET_STATE, boot_state,
-				 1)) < 0) {
+	if ((ret = wgw->read_byte(wgw, WGW_CTRL_REG_LAST_RESET_STATE,
+				  boot_state)) < 0) {
 		dev_err(wgw->dev, "failed to read from device\n");
 		*boot_state = 0xFF;
 	}
@@ -182,140 +252,241 @@ static int boot_state_fetch(struct wgw_ctrl_dev *wgw, u8 *boot_state)
 static int boot_state_clr_update(struct wgw_ctrl_dev *wgw, u8 *boot_state)
 {
 	int ret;
-	u8 reg = 0xFF;
-	if ((ret = wgw->write_dev(wgw, WGW_CTRL_REG_LAST_RESET_STATE, &reg,
-				  1)) < 0) {
+	if ((ret = wgw->write_byte(wgw, WGW_CTRL_REG_LAST_RESET_STATE, 0xFF)) <
+	    0) {
 		dev_err(wgw->dev, "failed to write to device\n");
 		return ret;
 	}
-
-	msleep(25);
 	// update local cache
 	return boot_state_fetch(wgw, boot_state);
 }
 
-static int serial_fetch(struct wgw_ctrl_dev *wgw, struct serial *serial)
+static int mem_slot_fetch(struct wgw_ctrl_dev *wgw, u8 slot_index,
+			  struct memory_slot *slot)
 {
-	int32_t ret;
-	size_t len;
-	// contains serial status, serial and termination character
-	char buffer[1 + HW_SN_MAX_SIZE];
+	int ret;
+	char buffer[32];
 
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_SN, buffer,
-				 sizeof(buffer))) < 0) {
-		dev_err(wgw->dev, "failed to read serial from device\n");
-		return ret;
+	if (slot_index > 3) {
+		dev_err(wgw->dev, "slot[%d] doesn't exist\n", slot_index);
+		return -EINVAL;
 	}
 
-	serial->status = (int)buffer[0];
-	if (!serial->status) {
-		// serial is not set
-		strcpy(serial->data, undefined_str);
-		return 0;
-	} else if (serial->status < 0) {
-		// error on MCU side
-		strcpy(serial->data, error_str);
+	if ((ret = wgw->read_block(wgw,
+				   WGW_CTRL_REG_MEM_SLOT0_CTRL + slot_index,
+				   buffer)) < 0) {
 		dev_err(wgw->dev,
-			"get serial error: mcu returned an error (%d)\n",
-			serial->status);
-		return -EIO;
+			"failed to read memory slot[%d] ctrl register\n",
+			slot_index);
+		return ret;
 	}
+	slot->flags = buffer[0] & MEM_SLOT_STATE_Msk;
+	slot->length = buffer[1];
+
+	if (!(slot->flags & MEM_SLOT_SET)) {
+		slot->length = 0;
+	} else {
+		if ((ret = wgw->read_block(wgw,
+					   WGW_CTRL_REG_MEM_SLOT0 + slot_index,
+					   buffer)) < 0) {
+			dev_err(wgw->dev,
+				"failed to read memory slot[%d] data register\n",
+				slot_index);
+			return ret;
+		}
+		if (ret != slot->length) {
+			dev_err(wgw->dev,
+				"failed to read memory slot[%d] data register, data length error\n",
+				slot_index);
+			return ret;
+		}
+		memcpy(slot->data, buffer, slot->length);
+	}
+	return slot->length;
+}
+
+static int mem_slot_set(struct wgw_ctrl_dev *wgw, u8 slot_index,
+			const struct memory_slot *slot)
+{
+	int ret;
+	char buffer[2];
 
-	if ((len = strnlen(&buffer[1], HW_SN_MAX_SIZE)) == HW_SN_MAX_SIZE) {
-		dev_err(wgw->dev, "get serial error: serial too long\n");
+	if (slot_index > 3) {
+		dev_err(wgw->dev, "slot[%d] doesn't exist\n", slot_index);
 		return -EINVAL;
 	}
-	if (!len) {
-		dev_err(wgw->dev,
-			"get serial error: cannot get serial (len = 0)\n");
+
+	// XOR compare
+	if (!(slot->flags & MEM_SLOT_SET) != !slot->length) {
+		dev_err(wgw->dev, "slot[%d] length and flags don't match\n",
+			slot_index);
 		return -EINVAL;
 	}
 
-	strcpy(serial->data, &buffer[1]);
-	return len;
+	buffer[0] = slot->flags;
+	buffer[1] = 0; // length has not effect
+	mutex_lock(&wgw->lock_ltr);
+	if (!slot->length) {
+		if ((ret = wgw->write_block(
+			     wgw, WGW_CTRL_REG_MEM_SLOT0_CTRL + slot_index,
+			     buffer, 2)) < 0) {
+			dev_err(wgw->dev,
+				"failed to write memory slot[%d] ctrl register\n",
+				slot_index);
+			mutex_unlock(&wgw->lock_ltr);
+			return ret;
+		}
+		ret = mcu_wait_ready(wgw);
+	} else {
+		// write data
+		if ((ret = wgw->write_block(wgw,
+					    WGW_CTRL_REG_MEM_SLOT0 + slot_index,
+					    slot->data, slot->length)) < 0) {
+			dev_err(wgw->dev,
+				"failed to write memory slot[%d] data register\n",
+				slot_index);
+			mutex_unlock(&wgw->lock_ltr);
+			return ret;
+		}
+		if ((ret = mcu_wait_ready(wgw)) < 0) {
+			mutex_unlock(&wgw->lock_ltr);
+			return ret;
+		}
+
+		// write control register
+		if ((ret = wgw->write_block(
+			     wgw, WGW_CTRL_REG_MEM_SLOT0_CTRL + slot_index,
+			     buffer, 2)) < 0) {
+			dev_err(wgw->dev,
+				"failed to write memory slot[%d] ctrl register\n",
+				slot_index);
+			mutex_unlock(&wgw->lock_ltr);
+			return ret;
+		}
+		ret = mcu_wait_ready(wgw);
+	}
+	mutex_unlock(&wgw->lock_ltr);
+	return ret;
+}
+
+static int serial_fetch(struct wgw_ctrl_dev *wgw, struct serial *serial)
+{
+	int ret;
+	struct memory_slot slot;
+	ret = mem_slot_fetch(wgw, 0, &slot);
+	if (ret < 0) {
+		serial->status = -1;
+		strcpy(serial->data, error_str);
+		return ret;
+	}
+	if (ret >= HW_SN_MAX_SIZE) {
+		serial->status = -1;
+		strcpy(serial->data, error_str);
+		dev_err(wgw->dev, "serial read from device is too long (%d)\n",
+			ret);
+		return -EIO;
+	}
+	serial->status = slot.flags;
+	if (!(slot.flags & MEM_SLOT_SET)) {
+		// slot is not set
+		strcpy(serial->data, undefined_str);
+	} else {
+		memcpy(serial->data, slot.data, slot.length);
+		// convert to null terminated string
+		serial->data[slot.length] = '\0';
+	}
+	return 0;
 }
 
 static int serial_set(struct wgw_ctrl_dev *wgw, char *src)
 {
-	int ret;
 	size_t len;
+	struct memory_slot slot;
 
 	if ((len = strnlen(src, HW_SN_MAX_SIZE)) == HW_SN_MAX_SIZE) {
 		dev_err(wgw->dev, "set serial error: serial too long\n");
 		return -EINVAL;
 	}
+
 	if (!len) {
 		dev_err(wgw->dev,
 			"set serial error: cannot be null (len = 0)\n");
 		return -EINVAL;
 	}
 
-	// send serial including \0
-	if ((ret = wgw->write_dev(wgw, WGW_CTRL_REG_SN, src, len + 1)) < 0) {
-		dev_err(wgw->dev, "failed to write to device\n");
-		return ret;
-	}
-	return len;
+	slot.flags = MEM_SLOT_SET_OTP;
+	slot.length = len;
+	memcpy(slot.data, src, len);
+	return mem_slot_set(wgw, 0, &slot);
 }
 
 static int hw_info_fetch(struct wgw_ctrl_dev *wgw, struct hw_info *hw_info)
 {
 	int32_t ret;
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_HW_INFO, (uint8_t *)hw_info,
-				 sizeof(struct hw_info) -
-					 sizeof(struct serial))) < 0) {
-		dev_err(wgw->dev, "failed to read hw_info from device\n");
+	u8 buffer[32];
+
+	if ((ret = wgw->read_block(wgw, WGW_CTRL_REG_HW_INFO, buffer)) < 0) {
+		dev_err(wgw->dev, "failed to read hw info\n");
 		return ret;
 	}
-	return serial_fetch(wgw, &hw_info->serial);
+	if (ret != sizeof(struct hw_info)) {
+		dev_err(wgw->dev,
+			"failed to read hw info (wrong returned size)\n");
+		return -EIO;
+	}
+	memcpy(hw_info, buffer, sizeof(struct hw_info));
+	return 0;
 }
 
 static int fw_info_fetch(struct wgw_ctrl_dev *wgw, struct fw_info *fw_info)
 {
 	int32_t ret;
+	u8 buffer[32];
 
 	// retrieve firmware version
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO1,
-				 (u8 *)&fw_info->version,
-				 sizeof(struct version))) < 0) {
+	if ((ret = wgw->read_block(wgw, WGW_CTRL_REG_FW_INFO1, buffer)) < 0) {
 		dev_err(wgw->dev, "failed to read firmware version (%d)\n",
 			ret);
 		return ret;
 	}
+	if (ret != sizeof(struct version)) {
+		dev_err(wgw->dev,
+			"failed to read firmware version (wrong returned size)\n");
+		return -EIO;
+	}
+	memcpy(&fw_info->version, buffer, sizeof(struct version));
 
 	// retrieve firmware commit hash
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO2,
-				 (u8 *)fw_info->commit_hash,
-				 APP_COMMIT_HASH_MAX_SIZE)) < 0) {
+	if ((ret = wgw->read_block(wgw, WGW_CTRL_REG_FW_INFO2, buffer)) < 0) {
 		dev_err(wgw->dev, "failed to read firmware commit hash (%d)\n",
 			ret);
 		return ret;
 	}
-	if (strnlen(fw_info->commit_hash, APP_COMMIT_HASH_MAX_SIZE) ==
-	    APP_COMMIT_HASH_MAX_SIZE) {
-		fw_info->commit_hash[0] = '\0';
+	if (ret >= APP_COMMIT_HASH_MAX_SIZE) {
 		dev_err(wgw->dev,
 			"firmware commit hash string is too longth (%d)\n",
 			ret);
-		return ret;
+		return -EIO;
 	}
+	memcpy(&fw_info->commit_hash[0], buffer, ret);
+	// convert to null terminated string
+	fw_info->commit_hash[ret] = '\0';
 
 	// retrieve firmware commit date
-	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO3,
-				 (u8 *)fw_info->commit_date,
-				 APP_COMMIT_DATE_MAX_SIZE)) < 0) {
+	if ((ret = wgw->read_block(wgw, WGW_CTRL_REG_FW_INFO3, buffer)) < 0) {
 		dev_err(wgw->dev, "failed to read firmware commit date (%d)\n",
 			ret);
 		return ret;
 	}
-	if (strnlen(fw_info->commit_date, APP_COMMIT_DATE_MAX_SIZE) ==
-	    APP_COMMIT_DATE_MAX_SIZE) {
-		fw_info->commit_date[0] = '\0';
+	if (ret >= APP_COMMIT_DATE_MAX_SIZE) {
 		dev_err(wgw->dev,
 			"firmware commit date string is too longth (%d)\n",
 			ret);
-		return ret;
+		return -EIO;
 	}
+	memcpy(&fw_info->commit_date[0], buffer, ret);
+	// convert to null terminated string
+	fw_info->commit_date[ret] = '\0';
 	return 0;
 }
 
@@ -397,9 +568,7 @@ static ssize_t product_model_show(struct device *dev,
 	struct product_info *info =
 		((struct wgw_ctrl_dev *)dev_get_drvdata(dev))->product_info;
 
-	return sprintf(buf, "%s\n",
-		       model_str((enum model)info->hw_info.model,
-				 (enum variant)info->hw_info.variant));
+	return sprintf(buf, "%s\n", model_str((enum model)info->hw_info.model));
 }
 
 static ssize_t product_variant_show(struct device *dev,
@@ -412,13 +581,23 @@ static ssize_t product_variant_show(struct device *dev,
 		       variant_str((enum variant)info->hw_info.variant));
 }
 
+static ssize_t product_frequency_show(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct product_info *info =
+		((struct wgw_ctrl_dev *)dev_get_drvdata(dev))->product_info;
+
+	return sprintf(buf, "%s\n",
+		       frequency_str((enum frequency)info->hw_info.frequency));
+}
+
 static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
 			   char *buf)
 {
 	struct product_info *info =
 		((struct wgw_ctrl_dev *)dev_get_drvdata(dev))->product_info;
 
-	return sprintf(buf, "%s\n", info->hw_info.serial.data);
+	return sprintf(buf, "%s\n", info->serial.data);
 }
 
 static ssize_t serial_store(struct device *dev, struct device_attribute *attr,
@@ -430,7 +609,7 @@ static ssize_t serial_store(struct device *dev, struct device_attribute *attr,
 	ssize_t ret;
 
 	// test if serial is writable
-	if (info->hw_info.serial.status) {
+	if (info->serial.status & MEM_SLOT_OTP) {
 		dev_err(wgw->dev, "serial is already set and not writable\n");
 		// the serial is set and cannot be overwritten
 		return -EACCES;
@@ -442,15 +621,11 @@ static ssize_t serial_store(struct device *dev, struct device_attribute *attr,
 	}
 
 	if (serial_set(wgw, serial) >= 0) {
-		// let MCU write the serial
-		msleep(25);
-
 		// read back to update local value
-		if ((ret = serial_fetch(wgw, &info->hw_info.serial)) < 0) {
+		if ((ret = serial_fetch(wgw, &info->serial)) < 0) {
 			dev_err(wgw->dev,
 				"reading back the serial failed: %d\n", ret);
-		} else if (strncmp(serial, info->hw_info.serial.data,
-				   HW_SN_MAX_SIZE)) {
+		} else if (strncmp(serial, info->serial.data, HW_SN_MAX_SIZE)) {
 			dev_err(wgw->dev,
 				"read serial doesn't match the written one\n");
 			ret = -EINVAL;
@@ -476,6 +651,7 @@ static ssize_t memory_nand_show(struct device *dev,
 static DEVICE_ATTR(dev_version, S_IRUGO, dev_version_show, NULL);
 static DEVICE_ATTR(model, S_IRUGO, product_model_show, NULL);
 static DEVICE_ATTR(variant, S_IRUGO, product_variant_show, NULL);
+static DEVICE_ATTR(frequency, S_IRUGO, product_frequency_show, NULL);
 static DEVICE_ATTR(serial, (S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH),
 		   serial_show, serial_store);
 static DEVICE_ATTR(boot_state,
@@ -488,12 +664,19 @@ static DEVICE_ATTR(hw_version, S_IRUGO, hw_version_show, NULL);
 static DEVICE_ATTR(mem_ram, S_IRUGO, memory_ram_show, NULL);
 static DEVICE_ATTR(mem_nand, S_IRUGO, memory_nand_show, NULL);
 static const struct attribute *machine_attrs[] = {
-	&dev_attr_dev_version.attr,	&dev_attr_model.attr,
-	&dev_attr_variant.attr,		&dev_attr_serial.attr,
-	&dev_attr_boot_state.attr,	&dev_attr_fw_version.attr,
-	&dev_attr_fw_version_hash.attr, &dev_attr_fw_version_date.attr,
-	&dev_attr_hw_version.attr,	&dev_attr_mem_ram.attr,
-	&dev_attr_mem_nand.attr,	NULL,
+	&dev_attr_dev_version.attr,
+	&dev_attr_model.attr,
+	&dev_attr_variant.attr,
+	&dev_attr_frequency.attr,
+	&dev_attr_serial.attr,
+	&dev_attr_boot_state.attr,
+	&dev_attr_fw_version.attr,
+	&dev_attr_fw_version_hash.attr,
+	&dev_attr_fw_version_date.attr,
+	&dev_attr_hw_version.attr,
+	&dev_attr_mem_ram.attr,
+	&dev_attr_mem_nand.attr,
+	NULL,
 };
 static const struct attribute_group machine_attr_group = {
 	.attrs = (struct attribute **)machine_attrs,
@@ -510,13 +693,13 @@ static int populate_info(struct wgw_ctrl_dev *wgw)
 	struct product_info *info = wgw->product_info;
 
 	/* Verify protocole version */
-	ret = wgw->read_dev(wgw, WGW_CTRL_REG_PROTOC_VER, buffer, 1);
+	ret = wgw->read_byte(wgw, WGW_CTRL_REG_PROTOC_VER, buffer);
 	if (ret < 0) {
 		dev_err(dev, "failed to read protocole version (%d)\n", ret);
 		return ret;
 	}
-	if (buffer[0] != 0x01) {
-		dev_err(dev, "protocol version %d not supported\n", ret);
+	if (buffer[0] != 2) {
+		dev_err(dev, "protocol version %d not supported\n", buffer[0]);
 		return -ENODEV;
 	}
 
@@ -531,6 +714,11 @@ static int populate_info(struct wgw_ctrl_dev *wgw)
 		return ret;
 	}
 
+	if ((ret = serial_fetch(wgw, &info->serial)) < 0) {
+		dev_err(dev, "failed to read serial (%d)\n", ret);
+		return ret;
+	}
+
 	ret = boot_state_fetch(wgw, &info->boot_state);
 	if (ret < 0) {
 		dev_err(dev, "failed to read boot state (%d)\n", ret);
@@ -546,50 +734,55 @@ static int verify_display_info(struct wgw_ctrl_dev *wgw)
 	struct product_info *info = wgw->product_info;
 
 	/* Verify the product is supported */
-	if (info->hw_info.model != PRODUCT_MODEL_WIFX_L1) {
+	if (info->hw_info.model != M_WIFX_L1) {
 		dev_err(dev, "Unknown product detected\n");
 		return -ENODEV;
 	}
 
 	dev_info(dev, "Wifx product detected\n");
-	dev_info(dev, "    Model: %s\n",
-		 model_str((enum model)info->hw_info.model,
-			   (enum variant)info->hw_info.variant));
-	dev_info(dev, "  Variant: %s\n",
-		 variant_str((enum variant)info->hw_info.variant));
-	if (model_index((enum model)info->hw_info.model,
-			(enum variant)info->hw_info.variant) < 0 ||
-	    variant_str((enum variant)info->hw_info.variant) < 0) {
+	if (model_index((enum model)info->hw_info.model) < 0 ||
+	    variant_index((enum variant)info->hw_info.variant) < 0 ||
+	    frequency_index((enum frequency)info->hw_info.frequency) < 0) {
 		dev_err(dev,
-			"Product model or variant not detected or unknown\n");
+			"Product model, variant and/or frequency not detected or unknown\n");
 		return -ENODEV;
 	}
-	if (!info->hw_info.serial.status) {
-		dev_warn(dev, "   Serial: %s\n", info->hw_info.serial.data);
-	} else if (info->hw_info.serial.status < 0) {
-		dev_err(dev, "   Serial: %s\n", info->hw_info.serial.data);
+	dev_info(dev, "     Model: %s\n",
+		 model_pretty_str((enum model)info->hw_info.model));
+	dev_info(dev, "   Variant: %s\n",
+		 variant_str((enum variant)info->hw_info.variant));
+	dev_info(dev, " Frequency: %s\n",
+		 frequency_str((enum frequency)info->hw_info.frequency));
+	if (!info->serial.status) {
+		dev_warn(dev, "    Serial: %s\n", info->serial.data);
+	} else if (info->serial.status < 0) {
+		dev_err(dev, "    Serial: %s\n", info->serial.data);
 	} else {
-		dev_info(dev, "   Serial: %s\n", info->hw_info.serial.data);
+		dev_info(dev, "    Serial: %s\n", info->serial.data);
+		if (!(info->serial.status & MEM_SLOT_OTP)) {
+			dev_warn(dev, "            serial is not locked\n");
+		}
 	}
-	dev_info(dev, "   HW ver: %s\n",
+	dev_info(dev, "    HW ver: %s\n",
 		 hw_version_str(&info->hw_info.version));
-	dev_info(dev, "   FW ver: %s (%s)\n",
+	dev_info(dev, "    FW ver: %s (%s)\n",
 		 fw_version_str(&info->fw_info.version),
 		 info->fw_info.commit_hash);
-	dev_info(dev, "           %s\n", info->fw_info.commit_date);
+	dev_info(dev, "            %s\n", info->fw_info.commit_date);
 
 	/* Display boot state */
 	switch (info->boot_state) {
 	case 0x00:
-		dev_info(dev, "  Boot: 0x00 (normal mode)\n");
+		dev_info(dev, "   Boot: 0x00 (normal mode)\n");
 		break;
 	case 0x01:
-		dev_info(dev, "  Boot: 0x01 (factory reset mode)\n");
+		dev_info(dev, "   Boot: 0x01 (factory reset mode)\n");
 		break;
 	default:
-		dev_info(dev,
-			 "  Boot: 0x%02X (unknown mode), clearing boot state\n",
-			 info->boot_state);
+		dev_info(
+			dev,
+			"   Boot: 0x%02X (unknown mode), clearing boot state\n",
+			info->boot_state);
 		ret = boot_state_clr_update(wgw, &info->boot_state);
 		if (ret < 0)
 			return ret;
@@ -657,12 +850,13 @@ int wgw_ctrl_device_init(struct wgw_ctrl_dev *wgw,
 	struct device *dev = wgw->dev;
 	struct device_node *np;
 	int ret, nb, i;
-	u8 reg;
 
 	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
 	if (ret)
 		return ret;
 
+	mutex_init(&wgw->lock_ltr);
+
 	/* Create the cache object */
 	wgw->product_info =
 		devm_kzalloc(dev, sizeof(struct product_info), GFP_KERNEL);
@@ -689,9 +883,7 @@ int wgw_ctrl_device_init(struct wgw_ctrl_dev *wgw,
 			wgw->irq_base = 0;
 		} else {
 			enable_irq(wgw->irq);
-
-			reg = 0x01;
-			wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
+			wgw->write_byte(wgw, WGW_CTRL_REG_INTERRUPT, 0x01);
 		}
 	} else {
 		dev_warn(wgw->dev,
diff --git a/drivers/mfd/wgw-ctrl-i2c.c b/drivers/mfd/wgw-ctrl-i2c.c
index f3d5ad6ddd2e..0e723be79888 100644
--- a/drivers/mfd/wgw-ctrl-i2c.c
+++ b/drivers/mfd/wgw-ctrl-i2c.c
@@ -24,59 +24,64 @@
 #include <linux/mfd/wgw-ctrl/core.h>
 #include <linux/mfd/wgw-ctrl/reg.h>
 
-#define PAQUET_MAX_LEN 32
+// Returns length read (>= 0) or error (< 0)
+static int read_byte(struct wgw_ctrl_dev *wgw, char command, u8 *data)
+{
+	struct i2c_client *i2c = wgw->i2c;
+
+	s32 result = i2c_smbus_read_byte_data(i2c, command);
+	if (result < 0) {
+		return result;
+	}
+	*data = (u8)result;
+	return 1;
+}
 
-static int wgw_ctrl_i2c_read_device(struct wgw_ctrl_dev *wgw, char reg,
-				    void *dest, int bytes)
+static int read_word(struct wgw_ctrl_dev *wgw, char command, u16 *data)
 {
 	struct i2c_client *i2c = wgw->i2c;
-	struct i2c_msg xfer[2];
-	int ret;
-
-	if (bytes > PAQUET_MAX_LEN)
-		return -EINVAL;
-
-	/* Send the register */
-	xfer[0].addr = i2c->addr;
-	xfer[0].flags = 0;
-	xfer[0].len = 1;
-	xfer[0].buf = &reg;
-
-	/* Read data back */
-	xfer[1].addr = i2c->addr;
-	xfer[1].flags = I2C_M_RD;
-	xfer[1].len = bytes;
-	xfer[1].buf = dest;
-
-	ret = i2c_transfer(i2c->adapter, xfer, 2);
-	if (ret == 2)
-		ret = 0;
-	else if (ret >= 0)
-		ret = -EIO;
-
-	return ret;
+
+	s32 result = i2c_smbus_read_word_data(i2c, command);
+	if (result < 0) {
+		return result;
+	}
+	*data = (u16)result;
+	return 1;
 }
 
-static int wgw_ctrl_i2c_write_device(struct wgw_ctrl_dev *wgw, char reg,
-				     void *src, int bytes)
+static int read_block(struct wgw_ctrl_dev *wgw, char command, u8 *data)
 {
 	struct i2c_client *i2c = wgw->i2c;
-	/* we add 1 byte for device register */
-	u8 msg[PAQUET_MAX_LEN + 1];
-	int ret;
+	return (int)i2c_smbus_read_block_data(i2c, command, data);
+}
 
-	if (bytes > PAQUET_MAX_LEN)
-		return -EINVAL;
+// Returns length written (>= 0) or error (< 0)
+static int write_byte(struct wgw_ctrl_dev *wgw, char command, u8 data)
+{
+	struct i2c_client *i2c = wgw->i2c;
 
-	msg[0] = reg;
-	memcpy(&msg[1], src, bytes);
+	s32 result = i2c_smbus_write_byte_data(i2c, command, data);
+	if (result < 0) {
+		return result;
+	}
+	return 1;
+}
 
-	ret = i2c_master_send(i2c, msg, bytes + 1);
-	if (ret < 0)
-		return ret;
-	if (ret != bytes + 1)
-		return -EIO;
-	return ret;
+static int write_word(struct wgw_ctrl_dev *wgw, char command, u16 data)
+{
+	struct i2c_client *i2c = wgw->i2c;
+
+	s32 result = i2c_smbus_write_word_data(i2c, command, data);
+	if (result < 0) {
+		return result;
+	}
+	return 2;
+}
+
+static int write_block(struct wgw_ctrl_dev *wgw, char command, u8 *data, u8 len)
+{
+	struct i2c_client *i2c = wgw->i2c;
+	return (int)i2c_smbus_write_block_data(i2c, command, len, data);
 }
 
 static int wgw_ctrl_i2c_probe(struct i2c_client *i2c,
@@ -90,11 +95,35 @@ static int wgw_ctrl_i2c_probe(struct i2c_client *i2c,
 	if (wgw == NULL)
 		return -ENOMEM;
 
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(&i2c->dev, "SMBUS Byte Data not Supported\n");
+		return -EIO;
+	}
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_WORD_DATA)) {
+		dev_err(&i2c->dev, "SMBUS Byte Data not Supported\n");
+		return -EIO;
+	}
+	if (!i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_BLOCK_DATA)) {
+		dev_err(&i2c->dev, "SMBUS Byte Data not Supported\n");
+		return -EIO;
+	}
+	if (i2c_check_functionality(i2c->adapter, I2C_FUNC_SMBUS_PEC)) {
+		i2c->flags |= I2C_CLIENT_PEC;
+	} else {
+		dev_err(&i2c->dev,
+			"SMBUS PEC is not supported, pass in unchecked mode\n");
+	}
+
 	i2c_set_clientdata(i2c, wgw);
 	wgw->dev = &i2c->dev;
 	wgw->i2c = i2c;
-	wgw->read_dev = wgw_ctrl_i2c_read_device;
-	wgw->write_dev = wgw_ctrl_i2c_write_device;
+	wgw->read_byte = read_byte;
+	wgw->read_word = read_word;
+	wgw->read_block = read_block;
+	wgw->write_byte = write_byte;
+	wgw->write_word = write_word;
+	wgw->write_block = write_block;
+
 	wgw->irq = i2c->irq;
 
 	if (pdata) {
diff --git a/drivers/mfd/wgw-ctrl-usbc.c b/drivers/mfd/wgw-ctrl-usbc.c
index 55bec64e3ffe..9eea9c586fc0 100644
--- a/drivers/mfd/wgw-ctrl-usbc.c
+++ b/drivers/mfd/wgw-ctrl-usbc.c
@@ -65,9 +65,9 @@ static int power_mode_get(struct wgw_ctrl_usbc_dev *usbc,
 	u8 reg;
 	struct wgw_ctrl_dev *wgw = usbc->wgw;
 
-	int ret = wgw->read_dev(wgw, WGW_CTRL_REG_USB_MODE_POWER, &reg, 1);
+	int ret = wgw->read_byte(wgw, WGW_CTRL_REG_USB_MODE_POWER, &reg);
 	if (ret < 0)
-		return -EIO;
+		return ret;
 
 	*usb_power_mode = reg;
 
@@ -87,7 +87,7 @@ static int data_mode_get(struct wgw_ctrl_usbc_dev *usbc,
 	u8 reg;
 	struct wgw_ctrl_dev *wgw = usbc->wgw;
 
-	int ret = wgw->read_dev(wgw, WGW_CTRL_REG_USB_MODE_DATA, &reg, 1);
+	int ret = wgw->read_byte(wgw, WGW_CTRL_REG_USB_MODE_DATA, &reg);
 	if (ret < 0)
 		return -EIO;
 
@@ -111,7 +111,7 @@ static int data_mode_set(struct wgw_ctrl_usbc_dev *usbc,
 	switch (reg) {
 	case USB_DATA_MODE_DEVICE:
 	case USB_DATA_MODE_HOST:
-		return wgw->write_dev(wgw, WGW_CTRL_REG_USB_MODE_DATA, &reg, 1);
+		return wgw->write_byte(wgw, WGW_CTRL_REG_USB_MODE_DATA, reg);
 	default:
 		return -EINVAL;
 	}
@@ -191,7 +191,7 @@ static int wgw_usbc_usbc_trig_notify(struct notifier_block *nb,
 		return NOTIFY_DONE;
 	}
 
-	ret = wgw->read_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
+	ret = wgw->read_byte(wgw, WGW_CTRL_REG_INTERRUPT, &reg);
 	if (ret < 0) {
 		dev_err(usbc->dev, "failed to read register USB-C data mode\n");
 		return NOTIFY_DONE;
@@ -199,8 +199,7 @@ static int wgw_usbc_usbc_trig_notify(struct notifier_block *nb,
 	pr_debug("isr reg: 0x%02X\n", reg);
 
 	/* Clear the interrupt flag */
-	reg = 0x01;
-	wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
+	wgw->write_byte(wgw, WGW_CTRL_REG_INTERRUPT, 0x01);
 
 	spin_lock_bh(&usbc->lock);
 	if (usbc->data_mode != usb_data_mode) {
diff --git a/include/linux/mfd/wgw-ctrl/core.h b/include/linux/mfd/wgw-ctrl/core.h
index ea7e0d52804c..be1a04ec4dc9 100644
--- a/include/linux/mfd/wgw-ctrl/core.h
+++ b/include/linux/mfd/wgw-ctrl/core.h
@@ -29,10 +29,17 @@ struct wgw_ctrl_dev {
 	struct wgw_ctrl_platform_data *pdata;
 
 	struct i2c_client *i2c;
-	int (*read_dev)(struct wgw_ctrl_dev *mcu, char reg, void *dest,
-			int size);
-	int (*write_dev)(struct wgw_ctrl_dev *mcu, char reg, void *src,
-			 int size);
+	struct mutex lock_ltr;
+
+	// Returns length read (>= 0) or error (< 0)
+	int (*read_byte)(struct wgw_ctrl_dev *mcu, char command, u8 *data);
+	int (*read_word)(struct wgw_ctrl_dev *mcu, char command, u16 *data);
+	int (*read_block)(struct wgw_ctrl_dev *mcu, char command, u8 *data);
+
+	// Returns length written (>= 0) or error (< 0)
+	int (*write_byte)(struct wgw_ctrl_dev *mcu, char command, u8 data);
+	int (*write_word)(struct wgw_ctrl_dev *mcu, char command, u16 data);
+	int (*write_block)(struct wgw_ctrl_dev *mcu, char command, u8 *data, u8 len);
 
 	// mcu cached values
 	void *product_info;
diff --git a/include/linux/mfd/wgw-ctrl/reg.h b/include/linux/mfd/wgw-ctrl/reg.h
index 58f868ad10ce..92639d27fe15 100644
--- a/include/linux/mfd/wgw-ctrl/reg.h
+++ b/include/linux/mfd/wgw-ctrl/reg.h
@@ -23,11 +23,18 @@
 #define WGW_CTRL_REG_FW_INFO2 0x21
 #define WGW_CTRL_REG_FW_INFO3 0x22
 #define WGW_CTRL_REG_FW_INFO4 0x23
-#define WGW_CTRL_REG_SN 0x24
+
+#define WGW_CTRL_REG_CMD_LTR_STATUS 0x30
+#define WGW_CTRL_REG_MEM_SLOT0 0x31
+#define WGW_CTRL_REG_MEM_SLOT0_CTRL 0x35
+
 #define WGW_CTRL_REG_LED_START 0x60
+
 #define WGW_CTRL_REG_LAST_RESET_STATE 0x70
+
 #define WGW_CTRL_REG_USB_MODE_POWER 0x80
 #define WGW_CTRL_REG_USB_MODE_DATA 0x81
+
 #define WGW_CTRL_REG_INTERRUPT 0xA0
 #define WGW_CTRL_REG_MAX 0xFF
 
-- 
2.25.1

