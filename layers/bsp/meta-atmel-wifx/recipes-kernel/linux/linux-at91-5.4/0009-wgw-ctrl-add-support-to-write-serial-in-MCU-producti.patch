From 3008ddfc90c17bf297ce9580785bed52d1012b19 Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Thu, 12 Aug 2021 17:35:32 +0200
Subject: [PATCH 09/11] wgw-ctrl: add support to write serial in MCU
 (production only)

Signed-off-by: Yannick Lanz <yannick.lanz@wifx.net>
---
 drivers/mfd/wgw-ctrl-core.c | 66 ++++++++++++++++++++++++++++++++++++-
 1 file changed, 65 insertions(+), 1 deletion(-)

diff --git a/drivers/mfd/wgw-ctrl-core.c b/drivers/mfd/wgw-ctrl-core.c
index 1ebe86ea2009..11b82742ad88 100644
--- a/drivers/mfd/wgw-ctrl-core.c
+++ b/drivers/mfd/wgw-ctrl-core.c
@@ -235,6 +235,29 @@ static int serial_fetch(struct wgw_ctrl_dev *wgw, struct serial *serial)
 	return len;
 }
 
+static int serial_set(struct wgw_ctrl_dev *wgw, char *src)
+{
+	int ret;
+	size_t len;
+
+	if ((len = strnlen(src, HW_SN_MAX_SIZE)) == HW_SN_MAX_SIZE) {
+		dev_err(wgw->dev, "set serial error: serial too long\n");
+		return -EINVAL;
+	}
+	if (!len) {
+		dev_err(wgw->dev,
+			"set serial error: cannot be null (len = 0)\n");
+		return -EINVAL;
+	}
+
+	// send serial including \0
+	if ((ret = wgw->write_dev(wgw, WGW_CTRL_REG_SN, src, len + 1)) < 0) {
+		dev_err(wgw->dev, "failed to write to device\n");
+		return ret;
+	}
+	return len;
+}
+
 static int hw_info_fetch(struct wgw_ctrl_dev *wgw, struct hw_info *hw_info)
 {
 	int32_t ret;
@@ -398,6 +421,46 @@ static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
 	return sprintf(buf, "%s\n", info->hw_info.serial.data);
 }
 
+static ssize_t serial_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t count)
+{
+	struct wgw_ctrl_dev *wgw = dev_get_drvdata(dev);
+	struct product_info *info = wgw->product_info;
+	char serial[HW_SN_MAX_SIZE];
+	ssize_t ret;
+
+	// test if serial is writable
+	if (info->hw_info.serial.status) {
+		dev_err(wgw->dev, "serial is already set and not writable\n");
+		// the serial is set and cannot be overwritten
+		return -EACCES;
+	}
+
+	ret = count - 1;
+	if (!ret || ret > 15 || sscanf(buf, "%15s\n", serial) <= 0) {
+		return -EINVAL;
+	}
+
+	if (serial_set(wgw, serial) >= 0) {
+		// let MCU write the serial
+		msleep(25);
+
+		// read back to update local value
+		if ((ret = serial_fetch(wgw, &info->hw_info.serial)) < 0) {
+			dev_err(wgw->dev,
+				"reading back the serial failed: %d\n", ret);
+		} else if (strncmp(serial, info->hw_info.serial.data,
+				   HW_SN_MAX_SIZE)) {
+			dev_err(wgw->dev,
+				"read serial doesn't match the written one\n");
+			ret = -EINVAL;
+		}
+	} else {
+		ret = -EIO;
+	}
+	return ret < 0 ? ret : count;
+}
+
 static ssize_t memory_ram_show(struct device *dev,
 			       struct device_attribute *attr, char *buf)
 {
@@ -413,7 +476,8 @@ static ssize_t memory_nand_show(struct device *dev,
 static DEVICE_ATTR(dev_version, S_IRUGO, dev_version_show, NULL);
 static DEVICE_ATTR(model, S_IRUGO, product_model_show, NULL);
 static DEVICE_ATTR(variant, S_IRUGO, product_variant_show, NULL);
-static DEVICE_ATTR(serial, S_IRUGO, serial_show, NULL);
+static DEVICE_ATTR(serial, (S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH),
+		   serial_show, serial_store);
 static DEVICE_ATTR(boot_state,
 		   (S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH),
 		   boot_state_show, boot_state_store);
-- 
2.25.1

