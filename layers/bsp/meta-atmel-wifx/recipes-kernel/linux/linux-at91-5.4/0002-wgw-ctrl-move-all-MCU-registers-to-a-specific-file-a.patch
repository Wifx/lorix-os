From 58f8bcfcc82d8c09ef1e675f7926c9fa42f3bd7e Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Thu, 5 Aug 2021 21:50:32 +0200
Subject: [PATCH 2/9] wgw-ctrl: move all MCU registers to a specific file and
 swap data/size in read/write i2c callbacks functions.

Signed-off-by: Yannick Lanz <yannick.lanz@wifx.net>
---
 drivers/leds/leds-wgw-ctrl.c      |  5 ++--
 drivers/mfd/wgw-ctrl-core.c       | 50 +++++++++++++++++--------------
 drivers/mfd/wgw-ctrl-i2c.c        | 11 +++----
 drivers/mfd/wgw-ctrl-usbc.c       | 19 +++++-------
 include/linux/mfd/wgw-ctrl/core.h | 12 ++++----
 include/linux/mfd/wgw-ctrl/reg.h  | 33 ++++++++++++++++++++
 6 files changed, 81 insertions(+), 49 deletions(-)
 create mode 100644 include/linux/mfd/wgw-ctrl/reg.h

diff --git a/drivers/leds/leds-wgw-ctrl.c b/drivers/leds/leds-wgw-ctrl.c
index 5e5a851eb963..73f62044b039 100644
--- a/drivers/leds/leds-wgw-ctrl.c
+++ b/drivers/leds/leds-wgw-ctrl.c
@@ -26,8 +26,7 @@
 
 #include <linux/mfd/wgw-ctrl/core.h>
 #include <linux/mfd/wgw-ctrl/led.h>
-
-#define REG_BRIGTHNESS_LED_BEGIN 0x60
+#include <linux/mfd/wgw-ctrl/reg.h>
 
 struct wgw_ctrl_leds;
 
@@ -53,7 +52,7 @@ static void wgw_ctrl_led_set_work(struct work_struct *work)
 	struct wgw_ctrl_dev *mcu = leds->master;
 
 	u8 brightness = led->new_brightness;
-	mcu->write_dev(mcu, REG_BRIGTHNESS_LED_BEGIN + led->id, 1, &brightness);
+	mcu->write_dev(mcu, WGW_CTRL_REG_LED_START + led->id, &brightness, 1);
 }
 
 static void wgw_ctrl_led_set(struct led_classdev *led_cdev,
diff --git a/drivers/mfd/wgw-ctrl-core.c b/drivers/mfd/wgw-ctrl-core.c
index 09e98965a50b..feec20c95274 100644
--- a/drivers/mfd/wgw-ctrl-core.c
+++ b/drivers/mfd/wgw-ctrl-core.c
@@ -28,19 +28,13 @@
 
 #include <linux/mfd/core.h>
 #include <linux/mfd/wgw-ctrl/core.h>
+#include <linux/mfd/wgw-ctrl/reg.h>
 
 #define PRODUCT_TYPE_WIFX_L1 0x10
 #define PRODUCT_SUBTYPE_8xx 0x00
 #define PRODUCT_SUBTYPE_9xx 0x02
 #define PRODUCT_SUBTYPE_Y_LYNX 0x08
 
-#define REG_PROTOC_VER 0x00
-#define REG_HW_INFO 0x10
-#define REG_FW_INFO1 0x20
-#define REG_FW_INFO2 0x21
-#define REG_FW_INFO3 0x22
-#define REG_LAST_RESET_STATE 0x70
-
 static struct mfd_cell wgw_ctrl_devs[] = {
 	{
 		.name = "wgw-ctrl-led",
@@ -80,17 +74,24 @@ struct product_info {
 
 static int boot_state_get(struct wgw_ctrl_dev *wgw, u8 *boot_state)
 {
-	int ret = wgw->read_dev(wgw, REG_LAST_RESET_STATE, 1, boot_state);
-	if (ret < 0)
+	int ret;
+	if ((ret = wgw->read_dev(wgw, WGW_CTRL_REG_LAST_RESET_STATE, boot_state,
+				 1)) < 0) {
+		dev_err(wgw->dev, "failed to read from device\n");
 		*boot_state = 0xFF;
-
+	}
 	return ret;
 }
 
 static int boot_state_clr(struct wgw_ctrl_dev *wgw)
 {
+	int ret;
 	u8 reg = 0xFF;
-	return wgw->write_dev(wgw, REG_LAST_RESET_STATE, 1, &reg);
+	if ((ret = wgw->write_dev(wgw, WGW_CTRL_REG_LAST_RESET_STATE, &reg,
+				  1)) < 0) {
+		dev_err(wgw->dev, "failed to write to device\n");
+	}
+	return ret;
 }
 
 static ssize_t dev_version_show(struct device *dev,
@@ -253,7 +254,7 @@ static int populate_info(struct wgw_ctrl_dev *wgw)
 	struct product_info *info = wgw->product_info;
 
 	/* Verify protocole version */
-	ret = wgw->read_dev(wgw, REG_PROTOC_VER, 1, buffer);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_PROTOC_VER, buffer, 1);
 	if (ret < 0) {
 		dev_err(dev, "failed to read protocole version (%d)\n", ret);
 		return ret;
@@ -264,28 +265,31 @@ static int populate_info(struct wgw_ctrl_dev *wgw)
 	}
 
 	/* Populate the cache */
-	ret = wgw->read_dev(wgw, REG_HW_INFO, sizeof(struct hw_info),
-			    (u8 *)&info->hw_info);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_HW_INFO, (u8 *)&info->hw_info,
+			    sizeof(struct hw_info));
 	if (ret < 0) {
 		dev_err(dev, "failed to read hardware info (%d)\n", ret);
 		return ret;
 	}
-	ret = wgw->read_dev(wgw, REG_FW_INFO1, sizeof(struct version),
-			    (u8 *)&info->fw_info.version);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO1,
+			    (u8 *)&info->fw_info.version,
+			    sizeof(struct version));
 	if (ret < 0) {
 		dev_err(dev, "failed to read firmware version (%d)\n", ret);
 		return ret;
 	}
-	ret = wgw->read_dev(wgw, REG_FW_INFO2,
-			    sizeof(info->fw_info.commit_hash),
-			    (u8 *)info->fw_info.commit_hash);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO2,
+			    (u8 *)info->fw_info.commit_hash,
+			    sizeof(info->fw_info.commit_hash));
+	info->fw_info.commit_hash[sizeof(info->fw_info.commit_hash) - 1] = '\0';
 	if (ret < 0) {
 		dev_err(dev, "failed to read firmware commit hash (%d)\n", ret);
 		return ret;
 	}
-	ret = wgw->read_dev(wgw, REG_FW_INFO3,
-			    sizeof(info->fw_info.commit_date),
-			    (u8 *)info->fw_info.commit_date);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_FW_INFO3,
+			    (u8 *)info->fw_info.commit_date,
+			    sizeof(info->fw_info.commit_date));
+	info->fw_info.commit_date[sizeof(info->fw_info.commit_date) - 1] = '\0';
 	if (ret < 0) {
 		dev_err(dev, "failed to read firmware commit date (%d)\n", ret);
 		return ret;
@@ -455,7 +459,7 @@ int wgw_ctrl_device_init(struct wgw_ctrl_dev *wgw,
 			enable_irq(wgw->irq);
 
 			reg = 0x01;
-			wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, 1, &reg);
+			wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
 		}
 	} else {
 		dev_warn(wgw->dev,
diff --git a/drivers/mfd/wgw-ctrl-i2c.c b/drivers/mfd/wgw-ctrl-i2c.c
index 7d80dd78df21..df5c0a9baa04 100644
--- a/drivers/mfd/wgw-ctrl-i2c.c
+++ b/drivers/mfd/wgw-ctrl-i2c.c
@@ -22,9 +22,10 @@
 #include <linux/slab.h>
 
 #include <linux/mfd/wgw-ctrl/core.h>
+#include <linux/mfd/wgw-ctrl/reg.h>
 
 static int wgw_ctrl_i2c_read_device(struct wgw_ctrl_dev *wgw, char reg,
-				    int bytes, void *dest)
+				    void *dest, int bytes)
 {
 	struct i2c_client *i2c = wgw->i2c;
 	struct i2c_msg xfer[2];
@@ -52,14 +53,14 @@ static int wgw_ctrl_i2c_read_device(struct wgw_ctrl_dev *wgw, char reg,
 }
 
 static int wgw_ctrl_i2c_write_device(struct wgw_ctrl_dev *wgw, char reg,
-				     int bytes, void *src)
+				     void *src, int bytes)
 {
 	struct i2c_client *i2c = wgw->i2c;
 	/* we add 1 byte for device register */
-	u8 msg[WGW_CTRL_MAX_REGISTER + 1];
+	u8 msg[WGW_CTRL_REG_MAX + 1];
 	int ret;
 
-	if (bytes > WGW_CTRL_MAX_REGISTER)
+	if (bytes > WGW_CTRL_REG_MAX)
 		return -EINVAL;
 
 	msg[0] = reg;
@@ -70,7 +71,7 @@ static int wgw_ctrl_i2c_write_device(struct wgw_ctrl_dev *wgw, char reg,
 		return ret;
 	if (ret != bytes + 1)
 		return -EIO;
-	return 0;
+	return ret;
 }
 
 static int wgw_ctrl_i2c_probe(struct i2c_client *i2c,
diff --git a/drivers/mfd/wgw-ctrl-usbc.c b/drivers/mfd/wgw-ctrl-usbc.c
index 8e9f84539716..fc3b78100705 100644
--- a/drivers/mfd/wgw-ctrl-usbc.c
+++ b/drivers/mfd/wgw-ctrl-usbc.c
@@ -24,11 +24,9 @@
 
 #include <linux/mfd/core.h>
 #include <linux/mfd/wgw-ctrl/core.h>
+#include <linux/mfd/wgw-ctrl/reg.h>
 #include <linux/mfd/wgw-ctrl/usbc.h>
 
-#define REG_USB_MODE_POWER 0x80
-#define REG_USB_MODE_DATA 0x81
-
 static const struct of_device_id wgw_ctrl_usbc_of_match[] = {
 	{
 		.compatible = "wifx,wgw-ctrl-usbc",
@@ -67,7 +65,7 @@ static int power_mode_get(struct wgw_ctrl_usbc_dev *usbc,
 	u8 reg;
 	struct wgw_ctrl_dev *wgw = usbc->wgw;
 
-	int ret = wgw->read_dev(wgw, REG_USB_MODE_POWER, 1, &reg);
+	int ret = wgw->read_dev(wgw, WGW_CTRL_REG_USB_MODE_POWER, &reg, 1);
 	if (ret < 0)
 		return -EIO;
 
@@ -89,7 +87,7 @@ static int data_mode_get(struct wgw_ctrl_usbc_dev *usbc,
 	u8 reg;
 	struct wgw_ctrl_dev *wgw = usbc->wgw;
 
-	int ret = wgw->read_dev(wgw, REG_USB_MODE_DATA, 1, &reg);
+	int ret = wgw->read_dev(wgw, WGW_CTRL_REG_USB_MODE_DATA, &reg, 1);
 	if (ret < 0)
 		return -EIO;
 
@@ -113,7 +111,7 @@ static int data_mode_set(struct wgw_ctrl_usbc_dev *usbc,
 	switch (reg) {
 	case USB_DATA_MODE_DEVICE:
 	case USB_DATA_MODE_HOST:
-		return wgw->write_dev(wgw, REG_USB_MODE_DATA, 1, &reg);
+		return wgw->write_dev(wgw, WGW_CTRL_REG_USB_MODE_DATA, &reg, 1);
 	default:
 		return -EINVAL;
 	}
@@ -148,11 +146,10 @@ static ssize_t data_mode_store(struct device *dev,
 	struct wgw_ctrl_usbc_dev *usbc = dev_get_drvdata(dev);
 	ssize_t status;
 
-	if (strlen("device\n") == count &&
-	    strncmp(buf, "device\n", count) == 0) {
+	if (strlen("device\n") == count && !strncmp(buf, "device\n", count)) {
 		status = data_mode_set(usbc, USB_DATA_MODE_DEVICE);
 	} else if (strlen("host\n") == count &&
-		   strncmp(buf, "host\n", count) == 0) {
+		   !strncmp(buf, "host\n", count)) {
 		status = data_mode_set(usbc, USB_DATA_MODE_HOST);
 	} else {
 		status = -EINVAL;
@@ -191,7 +188,7 @@ static int wgw_usbc_usbc_trig_notify(struct notifier_block *nb,
 		return NOTIFY_DONE;
 	}
 
-	ret = wgw->read_dev(wgw, WGW_CTRL_REG_INTERRUPT, 1, &reg);
+	ret = wgw->read_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
 	if (ret < 0) {
 		dev_err(usbc->dev, "failed to read register USB-C data mode\n");
 		return NOTIFY_DONE;
@@ -200,7 +197,7 @@ static int wgw_usbc_usbc_trig_notify(struct notifier_block *nb,
 
 	/* Clear the interrupt flag */
 	reg = 0x01;
-	wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, 1, &reg);
+	wgw->write_dev(wgw, WGW_CTRL_REG_INTERRUPT, &reg, 1);
 
 	spin_lock_bh(&usbc->lock);
 	if (usbc->data_mode != usb_data_mode) {
diff --git a/include/linux/mfd/wgw-ctrl/core.h b/include/linux/mfd/wgw-ctrl/core.h
index 5e9a37c36c9c..ea7e0d52804c 100644
--- a/include/linux/mfd/wgw-ctrl/core.h
+++ b/include/linux/mfd/wgw-ctrl/core.h
@@ -19,11 +19,9 @@
 
 #include <linux/kernel.h>
 #include <linux/mfd/wgw-ctrl/led.h>
+#include <linux/mfd/wgw-ctrl/reg.h>
 #include <linux/platform_device.h>
 
-#define WGW_CTRL_MAX_REGISTER 0xFF
-#define WGW_CTRL_REG_INTERRUPT 0xA0
-
 struct wgw_ctrl_leds_platform_data;
 
 struct wgw_ctrl_dev {
@@ -31,10 +29,10 @@ struct wgw_ctrl_dev {
 	struct wgw_ctrl_platform_data *pdata;
 
 	struct i2c_client *i2c;
-	int (*read_dev)(struct wgw_ctrl_dev *mcu, char reg, int size,
-			void *dest);
-	int (*write_dev)(struct wgw_ctrl_dev *mcu, char reg, int size,
-			 void *src);
+	int (*read_dev)(struct wgw_ctrl_dev *mcu, char reg, void *dest,
+			int size);
+	int (*write_dev)(struct wgw_ctrl_dev *mcu, char reg, void *src,
+			 int size);
 
 	// mcu cached values
 	void *product_info;
diff --git a/include/linux/mfd/wgw-ctrl/reg.h b/include/linux/mfd/wgw-ctrl/reg.h
new file mode 100644
index 000000000000..5118632dc48e
--- /dev/null
+++ b/include/linux/mfd/wgw-ctrl/reg.h
@@ -0,0 +1,33 @@
+/*
+ * Register information for Wifx WGW (board control) MFD driver
+ *
+ *  Copyright (C) 2021 Wifx,
+ *                2021 Yannick Lanz <yannick.lanz@wifx.net>
+ *
+ * This file is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __LINUX_MFD_WGW_CTRL_REG_H
+#define __LINUX_MFD_WGW_CTRL_REG_H
+
+#define WGW_CTRL_REG_PROTOC_VER 0x00
+#define WGW_CTRL_REG_HW_INFO 0x10
+#define WGW_CTRL_REG_FW_INFO1 0x20
+#define WGW_CTRL_REG_FW_INFO2 0x21
+#define WGW_CTRL_REG_FW_INFO3 0x22
+#define WGW_CTRL_REG_FW_INFO4 0x23
+#define WGW_CTRL_REG_LED_START 0x60
+#define WGW_CTRL_REG_LAST_RESET_STATE 0x70
+#define WGW_CTRL_REG_USB_MODE_POWER 0x80
+#define WGW_CTRL_REG_USB_MODE_DATA 0x81
+#define WGW_CTRL_REG_INTERRUPT 0xA0
+#define WGW_CTRL_REG_MAX 0xFF
+
+#endif /* __LINUX_MFD_WGW_CTRL_REG_H */
-- 
2.25.1

