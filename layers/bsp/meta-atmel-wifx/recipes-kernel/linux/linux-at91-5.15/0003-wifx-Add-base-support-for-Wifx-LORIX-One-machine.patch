From c7f3e3dea81a31204b46a62ee047262dea4a3c28 Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Sat, 30 Jul 2022 13:33:46 +0200
Subject: [PATCH 3/6] wifx: Add base support for Wifx LORIX One machine

Signed-off-by: Yannick Lanz <yannick.lanz@wifx.net>
---
 arch/arm/boot/dts/Makefile              |   4 +-
 arch/arm/boot/dts/lorix-one-256.dts     |  97 +++
 arch/arm/boot/dts/lorix-one-512.dts     |  95 +++
 arch/arm/boot/dts/lorix-one-base.dtsi   | 297 ++++++++
 arch/arm/configs/lorixone_defconfig     | 216 ++++++
 drivers/leds/Kconfig                    |  11 +
 drivers/leds/Makefile                   |   1 +
 drivers/leds/leds-pmic-lorix.c          | 235 +++++++
 drivers/mfd/Kconfig                     |  11 +
 drivers/mfd/Makefile                    |   1 +
 drivers/mfd/pmic-lorix.c                | 856 ++++++++++++++++++++++++
 drivers/usb/gadget/udc/atmel_usba_udc.c | 744 +++++++++++---------
 drivers/usb/gadget/udc/atmel_usba_udc.h |   1 +
 drivers/usb/host/ohci-at91.c            |  71 +-
 include/linux/mfd/pmic-lorix.h          |  71 ++
 15 files changed, 2409 insertions(+), 302 deletions(-)
 create mode 100644 arch/arm/boot/dts/lorix-one-256.dts
 create mode 100644 arch/arm/boot/dts/lorix-one-512.dts
 create mode 100644 arch/arm/boot/dts/lorix-one-base.dtsi
 create mode 100644 arch/arm/configs/lorixone_defconfig
 create mode 100644 drivers/leds/leds-pmic-lorix.c
 create mode 100644 drivers/mfd/pmic-lorix.c
 create mode 100644 include/linux/mfd/pmic-lorix.h

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 112931c17a40..f70309065989 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -75,7 +75,9 @@ dtb-$(CONFIG_SOC_SAM_V7) += \
 	at91-sama5d4_ma5d4evk.dtb \
 	at91-sama5d4_xplained.dtb \
 	at91-sama5d4ek.dtb \
-	at91-vinco.dtb
+	at91-vinco.dtb \
+	lorix-one-256.dtb \
+	lorix-one-512.dtb
 dtb-$(CONFIG_SOC_SAMA7G5) += \
 	at91-sama7g5ek.dtb
 dtb-$(CONFIG_ARCH_AXXIA) += \
diff --git a/arch/arm/boot/dts/lorix-one-256.dts b/arch/arm/boot/dts/lorix-one-256.dts
new file mode 100644
index 000000000000..ae71373e7dd3
--- /dev/null
+++ b/arch/arm/boot/dts/lorix-one-256.dts
@@ -0,0 +1,97 @@
+/*
+ * lorix-one-256.dts
+ *  Device Tree file for the LORIX One (256MB) LoRa gateway from
+ *  Wifx Sàrl
+ *
+ *  Copyright (C) 2018 Wifx Sarl <info@iot.wifx.net>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+/dts-v1/;
+#include "lorix-one-base.dtsi"
+
+/ {
+	model = "Wifx LORIX One (256MB NAND version)";
+	compatible = "wifx,lorix-one-256", "atmel,sama5d4", "atmel,sama5";
+
+	ahb {
+		ebi: ebi@10000000 {
+			nand_controller: nand-controller {
+				status = "okay";
+
+				nand@3 {
+					reg = <0x3 0x0 0x2>;
+					atmel,rb = <0>;
+					nand-bus-width = <8>;
+					nand-ecc-mode = "hw";
+					nand-ecc-strength = <4>;
+					nand-ecc-step-size = <512>;
+					nand-on-flash-bbt;
+					label = "atmel_nand";
+
+					partitions {
+						compatible = "fixed-partitions";
+						#address-cells = <1>;
+						#size-cells = <1>;
+
+						at91bootstrap@0 {
+							label = "at91bootstrap";
+							reg = <0x0 0x40000>;
+						};
+
+						uboot@40000 {
+							label = "uboot";
+							reg = <0x40000 0xC0000>;
+						};
+
+						uboot-env@100000 {
+							label = "uboot-env";
+							reg = <0x100000 0x80000>;
+						};
+
+						ubi@180000 {
+							label = "ubi";
+							reg = <0x180000 0x0FE80000>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/lorix-one-512.dts b/arch/arm/boot/dts/lorix-one-512.dts
new file mode 100644
index 000000000000..e0455a1c7d81
--- /dev/null
+++ b/arch/arm/boot/dts/lorix-one-512.dts
@@ -0,0 +1,95 @@
+/*
+ * lorix-one-512.dts
+ *  Device Tree file for the LORIX One (512MB) LoRa gateway from
+ *  Wifx Sàrl
+ *
+ *  Copyright (C) 2018 Wifx Sarl <info@iot.wifx.net>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+/dts-v1/;
+#include "lorix-one-base.dtsi"
+
+/ {
+	model = "Wifx LORIX One (512MB NAND version)";
+	compatible = "wifx,lorix-one-512", "atmel,sama5d4", "atmel,sama5";
+
+	ahb {
+		ebi: ebi@10000000 {
+			nand_controller: nand-controller {
+				status = "okay";
+
+				nand@3 {
+					reg = <0x3 0x0 0x2>;
+					atmel,rb = <0>;
+					nand-bus-width = <8>;
+					nand-ecc-mode = "hw";
+					nand-on-flash-bbt;
+					label = "atmel_nand";
+
+					partitions {
+						compatible = "fixed-partitions";
+						#address-cells = <1>;
+						#size-cells = <1>;
+
+						at91bootstrap@0 {
+							label = "at91bootstrap";
+							reg = <0x0 0x40000>;
+						};
+
+						uboot@40000 {
+							label = "uboot";
+							reg = <0x40000 0xC0000>;
+						};
+
+						uboot-env@100000 {
+							label = "uboot-env";
+							reg = <0x100000 0x80000>;
+						};
+
+						ubi@180000 {
+							label = "ubi";
+							reg = <0x180000 0x1FE80000>;
+						};
+					};
+				};
+			};
+		};
+	};
+};
diff --git a/arch/arm/boot/dts/lorix-one-base.dtsi b/arch/arm/boot/dts/lorix-one-base.dtsi
new file mode 100644
index 000000000000..603959dc615c
--- /dev/null
+++ b/arch/arm/boot/dts/lorix-one-base.dtsi
@@ -0,0 +1,297 @@
+/*
+ * lorix-one-base.dtsi
+ *  Device Tree file for the LORIX One (generic) LoRa gateway from
+ *  Wifx Sàrl
+ *
+ * Based on at91-sama5d4_xplained.dts
+ *  Device Tree file for SAMA5D4 Xplained board
+ *
+ *  Copyright (C) 2015 Atmel,
+ *                2015 Josh Wu <josh.wu@atmel.com>
+ *  Copyright (C) 2018 Wifx Sarl <info@iot.wifx.net>
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+#include "sama5d4.dtsi"
+
+/ {
+	compatible = "atmel,sama5d4", "atmel,sama5";
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	aliases {
+		rtc0 = &rtc_internal;
+		serial1 = &usart1;
+		eth0 = &macb0;
+	};
+
+	memory {
+		reg = <0x20000000 0x08000000>;
+	};
+
+	clocks {
+		slow_xtal {
+			clock-frequency = <32768>;
+		};
+
+		main_xtal {
+			clock-frequency = <12000000>;
+		};
+	};
+
+	ahb {
+		apb {
+			uart0: serial@f8004000 {
+				atmel,use-dma-rx;
+				atmel,use-dma-tx;
+				status = "okay";
+			};
+
+			spi0: spi@f8010000 {
+				cs-gpios = <&pioD 31 0>;
+				status = "okay";
+				sx1301@0 {
+					compatible = "semtech,sx1301";
+					spi-max-frequency = <10000000>;
+					reg = <0>;
+				};
+			};
+
+			i2c0: i2c@f8014000 {
+				status = "okay";
+
+				temp_sensor: lm75@4d {
+					compatible = "lm75";
+					reg = <0x4d>;
+					status = "okay";
+				};
+
+				i2c_eeprom: i2c_eeprom@58 {
+					compatible = "atmel,24mac402";
+					reg = <0x58>;
+					status = "okay";
+				};
+			};
+
+			i2c2: i2c@f8024000 {
+				status = "okay";
+
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+
+			macb0: ethernet@f8020000 {
+				phy-mode = "rmii";
+				status = "okay";
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_macb0_rmii &pinctrl_macb0_phy_irq>;
+
+				phy0: ethernet-phy@1 {
+					interrupt-parent = <&pioE>;
+					interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
+					reg = <1>;
+				};
+			};
+
+			mmc1: mmc@fc000000 {
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_mmc1_clk_cmd_dat0 &pinctrl_mmc1_dat1_3 &pinctrl_mmc1_cd>;
+				vmmc-supply = <&vcc_3v3_reg>;
+				vqmmc-supply = <&vcc_3v3_reg>;
+				status = "okay";
+				slot@0 {
+					reg = <0>;
+					bus-width = <4>;
+					cd-gpios = <&pioE 3 0>;
+				};
+			};
+
+			usart3: serial@fc00c000 {
+				atmel,use-dma-rx;
+				atmel,use-dma-tx;
+				status = "okay";
+			};
+
+			tcb0: timer@f801c000 {
+				timer0: timer@0 {
+					compatible = "atmel,tcb-timer";
+					reg = <0>;
+				};
+
+				timer1: timer@1 {
+					compatible = "atmel,tcb-timer";
+					reg = <1>;
+				};
+			};
+
+			/* disable unused TCB */
+			tcb1: timer@fc020000 {
+				status = "disabled";
+			};
+			tcb2: timer@fc024000 {
+				status = "disabled";
+			};
+
+			watchdog@fc068640 {
+				status = "okay";
+			};
+
+			rtc_internal:rtc@fc0686b0 {
+				status = "okay";
+			};
+
+			pinctrl@fc06a000 {
+				board {
+					pinctrl_mmc1_cd: mmc1_cd {
+						atmel,pins =
+							<AT91_PIOE 3 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH>;
+					};
+					pinctrl_usba_vbus: usba_vbus {
+						atmel,pins =
+							<AT91_PIOE 31 AT91_PERIPH_GPIO AT91_PINCTRL_DEGLITCH>;
+					};
+					pinctrl_usb_id: usb_id {
+						atmel,pins =
+							<AT91_PIOD 11 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH>;
+					};
+					pinctrl_macb0_phy_irq: macb0_phy_irq_0 {
+						atmel,pins =
+							<AT91_PIOE 0 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH>;
+					};
+					pinctrl_sx1301_rst: sx1301_rst {
+						atmel,pins =
+							<AT91_PIOA 1 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH>;
+					};
+					pinctrl_sx1301_scanmode: sx1301_scanmode {
+						atmel,pins =
+							<AT91_PIOA 2 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_DOWN>;
+					};
+				};
+			};
+		};
+
+		usb0: gadget@400000 {
+			atmel,vbus-gpio = <&pioE 31 GPIO_ACTIVE_HIGH>;
+			atmel,id-gpio = <&pioD 11 GPIO_ACTIVE_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usba_vbus>;
+			status = "okay";
+		};
+
+		usb1: ohci@500000 {
+			num-ports = <3>;
+			atmel,vbus-gpio = <&pioD 12 GPIO_ACTIVE_HIGH
+				0
+				0
+			>;
+			atmel,id-gpio = <&pioD 11 GPIO_ACTIVE_HIGH
+				0
+				0
+			>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&pinctrl_usb_id>;
+			status = "okay";
+		};
+
+		usb2: ehci@600000 {
+			status = "okay";
+		};
+
+		ebi: ebi@10000000 {
+			pinctrl-0 = <&pinctrl_ebi_cs3 &pinctrl_ebi_nrd_nandoe
+					 &pinctrl_ebi_nwe_nandwe &pinctrl_ebi_nandrdy
+					 &pinctrl_ebi_data_0_7 &pinctrl_ebi_nand_addr>;
+			pinctrl-names = "default";
+			status = "okay";
+		};
+	};
+
+	i2cmux {
+		compatible = "i2c-mux-gpio";
+		#address-cells = <1>;
+		#size-cells = <0>;
+		mux-gpios = <&pioB 31 GPIO_ACTIVE_HIGH>;
+		i2c-parent = <&i2c2>;
+		idle-state = <0>;
+
+		i2c@1 {
+			reg = <1>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			pmic-lorix@60 {
+				compatible = "wifx,pmic-lorix";
+				reg = <0x60>;
+
+				leds {
+					compatible = "wifx,pmic-lorix-led";
+					#address-cells = <1>;
+					#size-cells = <0>;
+					led-control = <0x000 0x000 0x0e0 0x000>;
+
+					sysled {
+						reg = <0>;
+						label = "status";
+						linux,default-trigger = "heartbeat";
+					};
+				};
+			};
+		};
+	};
+
+    vcc_3v3_reg: fixedregulator_3v3 {
+		compatible = "regulator-fixed";
+		regulator-name = "VCC 3V3";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+
+	vddbu_2v_reg: fixedregulator@0 {
+		compatible = "regulator-fixed";
+		regulator-name = "VDDBU 2V";
+		regulator-min-microvolt = <2000000>;
+		regulator-max-microvolt = <2000000>;
+		regulator-boot-on;
+		regulator-always-on;
+	};
+};
diff --git a/arch/arm/configs/lorixone_defconfig b/arch/arm/configs/lorixone_defconfig
new file mode 100644
index 000000000000..ebe253b7261b
--- /dev/null
+++ b/arch/arm/configs/lorixone_defconfig
@@ -0,0 +1,216 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_NO_HZ_IDLE=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_LOG_BUF_SHIFT=16
+CONFIG_CGROUPS=y
+CONFIG_MEMCG=y
+CONFIG_CGROUP_SCHED=y
+CONFIG_CFS_BANDWIDTH=y
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_KALLSYMS is not set
+CONFIG_EMBEDDED=y
+CONFIG_ARCH_AT91=y
+CONFIG_SOC_SAMA5D4=y
+CONFIG_FORCE_MAX_ZONEORDER=15
+CONFIG_UACCESS_WITH_MEMCPY=y
+# CONFIG_ATAGS is not set
+CONFIG_CMDLINE="console=ttyS0,115200 initrd=0x21100000,25165824 root=/dev/ram0 rw"
+CONFIG_CPU_IDLE=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+CONFIG_PM_DEBUG=y
+CONFIG_PM_ADVANCED_DEBUG=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_CMA=y
+CONFIG_CMA_DEBUGFS=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_INET_DIAG is not set
+CONFIG_UEVENT_HELPER=y
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_CFI=y
+CONFIG_MTD_RAW_NAND=y
+CONFIG_MTD_NAND_ATMEL=y
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_GLUEBI=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=8192
+CONFIG_ATMEL_SSC=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_93CX6=m
+CONFIG_NETDEVICES=y
+CONFIG_TUN=m
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_MACB=y
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MICREL_PHY=y
+# CONFIG_USB_NET_DRIVERS is not set
+# CONFIG_WLAN is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_LEGACY_PTY_COUNT=4
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+CONFIG_HW_RANDOM=y
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+CONFIG_I2C_MUX_GPIO=y
+CONFIG_I2C_AT91=y
+CONFIG_SPI=y
+CONFIG_SPI_ATMEL=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PINCTRL_AT91PIO4=y
+CONFIG_GPIO_SYSFS=y
+CONFIG_GPIO_SYSCON=y
+CONFIG_POWER_RESET=y
+CONFIG_POWER_SUPPLY=y
+CONFIG_BATTERY_ACT8945A=y
+CONFIG_SENSORS_LM75=y
+CONFIG_THERMAL=y
+CONFIG_WATCHDOG=y
+CONFIG_AT91SAM9X_WATCHDOG=y
+CONFIG_SAMA5D4_WATCHDOG=y
+CONFIG_MFD_ACT8945A=y
+CONFIG_PMIC_LORIX_ONE=y
+CONFIG_MFD_ATMEL_FLEXCOM=y
+CONFIG_MFD_ATMEL_HLCDC=y
+CONFIG_REGULATOR=y
+CONFIG_REGULATOR_FIXED_VOLTAGE=y
+CONFIG_REGULATOR_VIRTUAL_CONSUMER=y
+CONFIG_REGULATOR_ACT8865=y
+CONFIG_REGULATOR_ACT8945A=y
+# CONFIG_HID is not set
+# CONFIG_USB_HID is not set
+CONFIG_USB=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_OHCI_HCD=y
+CONFIG_USB_ACM=y
+CONFIG_USB_SERIAL=y
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_SERIAL_FTDI_SIO=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_ATMEL_USBA=y
+CONFIG_USB_CONFIGFS=m
+CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_G_SERIAL=m
+CONFIG_MMC=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_OF_AT91=y
+CONFIG_MMC_ATMELMCI=y
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_LORIX_ONE=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+CONFIG_LEDS_TRIGGER_CPU=y
+CONFIG_LEDS_TRIGGER_GPIO=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_AT91RM9200=y
+CONFIG_DMADEVICES=y
+CONFIG_AT_XDMAC=y
+CONFIG_DMATEST=m
+CONFIG_STAGING=y
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_IIO=y
+CONFIG_IIO_BUFFER=y
+CONFIG_IIO_KFIFO_BUF=y
+CONFIG_IIO_TRIGGER=y
+CONFIG_RESET_CONTROLLER=y
+CONFIG_EXT4_FS=y
+CONFIG_FANOTIFY=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_UBIFS_FS=y
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=m
+CONFIG_ROOT_NFS=y
+CONFIG_NFSD=m
+CONFIG_NFSD_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_850=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_CRYPTO_AUTHENC=y
+CONFIG_CRYPTO_ECDH=y
+CONFIG_CRYPTO_CCM=y
+CONFIG_CRYPTO_GCM=y
+CONFIG_CRYPTO_ECHAINIV=m
+CONFIG_CRYPTO_CBC=y
+CONFIG_CRYPTO_XTS=y
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA512=y
+CONFIG_CRYPTO_SM3=y
+CONFIG_CRYPTO_ARC4=y
+CONFIG_CRYPTO_DES=y
+CONFIG_CRYPTO_SM4=y
+CONFIG_CRYPTO_USER_API_HASH=m
+CONFIG_CRYPTO_USER_API_SKCIPHER=m
+CONFIG_CRYPTO_DEV_ATMEL_AES=y
+CONFIG_CRYPTO_DEV_ATMEL_TDES=y
+CONFIG_CRYPTO_DEV_ATMEL_SHA=y
+CONFIG_CRC_CCITT=m
+CONFIG_CRC_ITU_T=m
+CONFIG_STRIP_ASM_SYMS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
diff --git a/drivers/leds/Kconfig b/drivers/leds/Kconfig
index ed800f5da7d8..5c3b244059c2 100644
--- a/drivers/leds/Kconfig
+++ b/drivers/leds/Kconfig
@@ -594,6 +594,17 @@ config LEDS_LT3593
 	  LT3593 controller. This controller uses a special one-wire pulse
 	  coding protocol to set the brightness.
 
+config LEDS_LORIX_ONE
+	tristate "LED support for Wifx LORIX One PMIC (Status LED)"
+	depends on LEDS_CLASS
+	depends on PMIC_LORIX_ONE
+	help
+	  This option enables support for on-chip LED drivers managed
+	  by the integrated custom PMIC.
+
+	  To compile this driver as a module, choose M here: the module will
+	  be called leds-pmic-lorix.
+
 config LEDS_ADP5520
 	tristate "LED Support for ADP5520/ADP5501 PMIC"
 	depends on LEDS_CLASS
diff --git a/drivers/leds/Makefile b/drivers/leds/Makefile
index c636ec069612..2af693f07ff5 100644
--- a/drivers/leds/Makefile
+++ b/drivers/leds/Makefile
@@ -55,6 +55,7 @@ obj-$(CONFIG_LEDS_LP8501)		+= leds-lp8501.o
 obj-$(CONFIG_LEDS_LP8788)		+= leds-lp8788.o
 obj-$(CONFIG_LEDS_LP8860)		+= leds-lp8860.o
 obj-$(CONFIG_LEDS_LT3593)		+= leds-lt3593.o
+obj-$(CONFIG_LEDS_LORIX_ONE)		+= leds-pmic-lorix.o
 obj-$(CONFIG_LEDS_MAX77650)		+= leds-max77650.o
 obj-$(CONFIG_LEDS_MAX8997)		+= leds-max8997.o
 obj-$(CONFIG_LEDS_MC13783)		+= leds-mc13783.o
diff --git a/drivers/leds/leds-pmic-lorix.c b/drivers/leds/leds-pmic-lorix.c
new file mode 100644
index 000000000000..9f08717423e8
--- /dev/null
+++ b/drivers/leds/leds-pmic-lorix.c
@@ -0,0 +1,235 @@
+/*
+ * LEDs driver for the LORIX One PMIC/Reset controller
+ *
+ *  Copyright (C) 2016 Wifx,
+ *                2016 Yannick Lanz <yannick.lanz@wifx.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/of.h>
+#include <linux/mfd/pmic-lorix.h>
+
+#define LORIX_DISP_LED_NAME "status_led"
+
+struct attiny_led {
+	struct led_classdev cdev;
+	struct work_struct work;
+	enum led_brightness new_brightness;
+	int id;
+	struct attiny_leds *leds;
+};
+
+struct attiny_leds {
+	struct attiny *master;
+	int num_leds;
+	struct attiny_led *led;
+};
+
+static void attiny_led_set_work(struct work_struct *work)
+{
+	struct attiny_led *led = container_of(work, struct attiny_led, work);
+	struct attiny_leds *leds = led->leds;
+
+	pmic_lorix_write(leds->master, 0x01, led->new_brightness);
+}
+
+static void attiny_led_set(struct led_classdev *led_cdev,
+			   enum led_brightness value)
+{
+	struct attiny_led *led =
+		container_of(led_cdev, struct attiny_led, cdev);
+
+	led->new_brightness = value;
+	schedule_work(&led->work);
+}
+
+#ifdef CONFIG_OF
+static struct attiny_leds_platform_data __init *
+attiny_led_probe_dt(struct platform_device *pdev)
+{
+	struct attiny_leds_platform_data *pdata;
+	struct device_node *parent, *child;
+	struct device *dev = &pdev->dev;
+	int i = 0, ret = -ENODATA;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	parent = of_get_child_by_name(dev->parent->of_node, "leds");
+	if (!parent)
+		goto out_node_put;
+
+	ret = of_property_read_u32_array(parent, "led-control",
+					 pdata->led_control, 1);
+	if (ret)
+		goto out_node_put;
+
+	pdata->num_leds = of_get_child_count(parent);
+
+	pdata->led = devm_kzalloc(dev, pdata->num_leds * sizeof(*pdata->led),
+				  GFP_KERNEL);
+	if (!pdata->led) {
+		ret = -ENOMEM;
+		goto out_node_put;
+	}
+
+	for_each_child_of_node (parent, child) {
+		const char *str;
+		u32 tmp;
+
+		if (of_property_read_u32(child, "reg", &tmp))
+			continue;
+		pdata->led[i].id = 0 + tmp;
+
+		if (!of_property_read_string(child, "label", &str))
+			pdata->led[i].name = str;
+		if (!of_property_read_string(child, "linux,default-trigger",
+					     &str))
+			pdata->led[i].default_trigger = str;
+
+		i++;
+	}
+
+	pdata->num_leds = i;
+	ret = i > 0 ? 0 : -ENODATA;
+
+out_node_put:
+	of_node_put(parent);
+
+	return ret ? ERR_PTR(ret) : pdata;
+}
+#else
+static inline struct attiny_leds_platform_data __init *
+attiny_led_probe_dt(struct platform_device *pdev)
+{
+	return ERR_PTR(-ENOSYS);
+}
+#endif
+
+static int __init attiny_led_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct attiny_leds_platform_data *pdata = dev_get_platdata(dev);
+	struct attiny *atdev = dev_get_drvdata(dev->parent);
+	struct attiny_leds *leds;
+	int i, id, ret = -ENODATA;
+	u32 init_led = 0;
+
+	leds = devm_kzalloc(dev, sizeof(*leds), GFP_KERNEL);
+	if (!leds)
+		return -ENOMEM;
+
+	leds->master = atdev;
+	platform_set_drvdata(pdev, leds);
+
+	if (dev->parent->of_node) {
+		pdata = attiny_led_probe_dt(pdev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	} else if (!pdata)
+		return -ENODATA;
+
+	leds->num_leds = pdata->num_leds;
+
+	leds->led = devm_kzalloc(dev, leds->num_leds * sizeof(*leds->led),
+				 GFP_KERNEL);
+	if (!leds->led)
+		return -ENOMEM;
+
+	for (i = 0; i < leds->num_leds; i++) {
+		const char *name, *trig;
+
+		ret = -EINVAL;
+
+		id = pdata->led[i].id;
+		name = pdata->led[i].name;
+		trig = pdata->led[i].default_trigger;
+
+		if ((id > 1) || (id < 0)) {
+			dev_err(dev, "Invalid ID %i\n", id);
+			break;
+		}
+
+		if (init_led & (1 << id)) {
+			dev_warn(dev, "LED %i already initialized\n", id);
+			break;
+		}
+
+		init_led |= 1 << id;
+		leds->led[i].id = id;
+		leds->led[i].leds = leds;
+		leds->led[i].cdev.name = name;
+		leds->led[i].cdev.default_trigger = trig;
+		leds->led[i].cdev.flags = LED_CORE_SUSPENDRESUME;
+		leds->led[i].cdev.brightness_set = attiny_led_set;
+		leds->led[i].cdev.max_brightness = 255;
+
+		INIT_WORK(&leds->led[i].work, attiny_led_set_work);
+
+		ret = led_classdev_register(dev->parent, &leds->led[i].cdev);
+		if (ret) {
+			dev_err(dev, "Failed to register LED %i\n", id);
+			break;
+		} else {
+			dev_info(dev,
+				 "registred led (name = %s, trigger = %s)\n",
+				 name, trig);
+		}
+	}
+
+	if (ret)
+		while (--i >= 0) {
+			led_classdev_unregister(&leds->led[i].cdev);
+			cancel_work_sync(&leds->led[i].work);
+		}
+
+	return ret;
+}
+
+static int attiny_led_remove(struct platform_device *pdev)
+{
+	struct attiny_leds *leds = platform_get_drvdata(pdev);
+	int i;
+
+	for (i = 0; i < leds->num_leds; i++) {
+		led_classdev_unregister(&leds->led[i].cdev);
+		cancel_work_sync(&leds->led[i].work);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id pmic_lorix_led_of_match[] = {
+	{
+		.compatible = "wifx,pmic-lorix-led",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, pmic_lorix_led_of_match);
+#endif
+
+static struct platform_driver attiny_led_driver = {
+	.driver = {
+		.name	= "pmic-lorix-led",
+		.of_match_table = of_match_ptr(pmic_lorix_led_of_match),
+	},
+	.remove   = attiny_led_remove,
+};
+
+module_platform_driver_probe(attiny_led_driver, attiny_led_probe);
+
+MODULE_AUTHOR("Yannick Lanz <yannick.lanz@wifx.net>");
+MODULE_DESCRIPTION("LORIX One Status LED");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index d2f345245538..da6e2fbb690f 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -99,6 +99,17 @@ config PMIC_ADP5520
 	  individual components like LCD backlight, LEDs, GPIOs and Kepad
 	  under the corresponding menus.
 
+config PMIC_LORIX_ONE
+	tristate "LORIX One PMIC Core Support"
+	select MFD_CORE
+	depends on I2C=y
+	help
+	  Say yes here to add support for reset controller/PMIC integrated
+	  on LORIX One main PCB and based on ATTiny microcontroller.
+	  This includes the I2C driver and the core API _only_, you have to
+	  select individual components likes LEDs and reset status under the
+	  corresponding menus.
+
 config MFD_AAT2870_CORE
 	bool "AnalogicTech AAT2870"
 	select MFD_CORE
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 2ba6646e874c..72fa527a7b14 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -183,6 +183,7 @@ obj-$(CONFIG_MFD_DB8500_PRCMU)	+= db8500-prcmu.o
 obj-$(CONFIG_AB8500_CORE)	+= ab8500-core.o ab8500-sysctrl.o
 obj-$(CONFIG_MFD_TIMBERDALE)    += timberdale.o
 obj-$(CONFIG_PMIC_ADP5520)	+= adp5520.o
+obj-$(CONFIG_PMIC_LORIX_ONE)	+= pmic-lorix.o
 obj-$(CONFIG_MFD_KEMPLD)	+= kempld-core.o
 obj-$(CONFIG_MFD_INTEL_QUARK_I2C_GPIO)	+= intel_quark_i2c_gpio.o
 obj-$(CONFIG_LPC_SCH)		+= lpc_sch.o
diff --git a/drivers/mfd/pmic-lorix.c b/drivers/mfd/pmic-lorix.c
new file mode 100644
index 000000000000..093e92e36ebd
--- /dev/null
+++ b/drivers/mfd/pmic-lorix.c
@@ -0,0 +1,856 @@
+/*
+ * Driver to communicate with the LORIX One PMIC/Reset controller
+ *
+ *  Copyright (C) 2016-2020 Wifx,
+ *                2016-2020 Yannick Lanz <yannick.lanz@wifx.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#include <linux/kernel.h>
+#include <linux/dma-mapping.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/of.h>
+#include <linux/netdevice.h>
+
+#include <linux/leds.h>
+
+#include <linux/mfd/pmic-lorix.h>
+#include <linux/mfd/core.h>
+
+#define REG_LAST_RESET_STATE 0x00
+#define REG_LED_BRIGTHNESS 0x01
+#define REG_FW_VERSION_LENGTH 0x02
+#define REG_FW_VERSION 0x03
+#define REG_HW_VERSION_LENGTH 0x04
+#define REG_HW_VERSION 0x05
+#define REG_PRODUCT_NAME_LENGTH 0x06
+#define REG_PRODUCT_NAME 0x07
+#define REG_PRODUCT_TYPE_LENGTH 0x08
+#define REG_PRODUCT_TYPE 0x09
+#define REG_FEATURE1 0x0A
+#define REG_FEATURE2 0x0B
+
+static struct mfd_cell pmic_lorix_devs[] = {
+	{
+		.name = "pmic-lorix-led",
+		.of_compatible = "wifx,pmic-lorix-led",
+	},
+};
+
+typedef struct __attribute__((packed, aligned(1))) {
+	union {
+		uint8_t raw;
+		struct {
+			uint8_t FEAT_LEGACY : 1;
+			uint8_t FEAT_BOOT : 1;
+			uint8_t FEAT_FW_VER : 1;
+			uint8_t FEAT_HW_VER : 1;
+			uint8_t FEAT_NAME : 1;
+			uint8_t FEAT_TYPE : 1;
+			uint8_t FEAT_PROG : 1;
+			uint8_t FEAT_UNUSED : 1;
+		} bit;
+	};
+} reg_feature1_t;
+
+typedef struct __attribute__((packed, aligned(1))) {
+	union {
+		uint8_t raw;
+		struct {
+			uint8_t FEAT_UNUSED : 8;
+		} bit;
+	};
+} reg_feature2_t;
+
+typedef struct {
+	reg_feature1_t feature1;
+	reg_feature2_t feature2;
+	char fw_ver[16];
+	char hw_ver[16];
+	char name[16];
+	char type[16];
+	char serial[20];
+} attiny_cache_t;
+
+static int __lorix_read(struct i2c_client *client, int reg, uint8_t *val)
+{
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
+		return ret;
+	}
+
+	*val = (uint8_t)ret;
+	return 0;
+}
+
+static int __lorix_write(struct i2c_client *client, int reg, uint8_t val)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n", val,
+			reg);
+		return ret;
+	}
+	return 0;
+}
+
+int pmic_lorix_write(struct attiny *attiny, int reg, uint8_t val)
+{
+	int ret;
+	mutex_lock(&attiny->lock);
+
+	ret = __lorix_write(attiny->client, reg, val);
+
+	mutex_unlock(&attiny->lock);
+	return ret;
+}
+EXPORT_SYMBOL(pmic_lorix_write);
+
+int pmic_lorix_read(struct attiny *attiny, int reg, uint8_t *val)
+{
+	int ret;
+	mutex_lock(&attiny->lock);
+
+	ret = __lorix_read(attiny->client, reg, val);
+
+	mutex_unlock(&attiny->lock);
+	return ret;
+}
+EXPORT_SYMBOL(pmic_lorix_read);
+
+static int boot_state_get(struct attiny *attiny, uint8_t *boot_state)
+{
+	int ret = pmic_lorix_read(attiny, REG_LAST_RESET_STATE, boot_state);
+	if (ret < 0)
+		*boot_state = 0xFF;
+
+	return ret;
+}
+
+static int boot_state_clr(struct attiny *attiny)
+{
+	return pmic_lorix_write(attiny, REG_LAST_RESET_STATE, 0xFF);
+}
+
+static int fw_version_get(struct attiny *attiny, char *str)
+{
+	int ret;
+	uint8_t len;
+	char tmp[10];
+
+	mutex_lock(&attiny->lock);
+
+	ret = i2c_smbus_read_byte_data(attiny->client, REG_FW_VERSION_LENGTH);
+	if (ret < 0) {
+		dev_err(attiny->dev,
+			"failed reading register FW_VERSION_LENGTH\n");
+		goto out_err_read;
+	}
+	len = (uint8_t)ret;
+	if (len > 10) {
+		dev_err(attiny->dev,
+			"error with FW version length (length read = %d)\n",
+			len);
+		goto out_err_read;
+	}
+
+	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_FW_VERSION,
+					    (uint8_t)ret, tmp);
+	if (ret < 0) {
+		dev_err(attiny->dev, "failed reading register FW_VERSION\n");
+		goto out_err_read;
+	}
+
+	mutex_unlock(&attiny->lock);
+
+	strncpy(str, tmp, len);
+	return (int)len;
+
+out_err_read:
+	mutex_unlock(&attiny->lock);
+	dev_err(attiny->dev, "failed retrieving FW version\n");
+	return -EIO;
+}
+
+static int hw_version_get(struct attiny *attiny, char *str)
+{
+	int ret;
+	uint8_t len;
+	char tmp[10];
+
+	mutex_lock(&attiny->lock);
+
+	ret = i2c_smbus_read_byte_data(attiny->client, REG_HW_VERSION_LENGTH);
+	if (ret < 0) {
+		dev_err(attiny->dev,
+			"failed reading register HW_VERSION_LENGTH\n");
+		goto out_err_read;
+	}
+	len = (uint8_t)ret;
+	if (len > 10) {
+		dev_err(attiny->dev,
+			"error with HW version length (length read = %d)\n",
+			len);
+		goto out_err_read;
+	}
+
+	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_HW_VERSION,
+					    (uint8_t)ret, tmp);
+	if (ret < 0) {
+		dev_err(attiny->dev, "failed reading register HW_VERSION\n");
+		goto out_err_read;
+	}
+
+	mutex_unlock(&attiny->lock);
+
+	strncpy(str, tmp, len);
+	return (int)len;
+
+out_err_read:
+	mutex_unlock(&attiny->lock);
+	dev_err(attiny->dev, "failed retrieving HW version\n");
+	return -EIO;
+}
+
+static int product_name_get(struct attiny *attiny, char *str)
+{
+	int ret;
+	uint8_t len;
+	char tmp[16];
+
+	mutex_lock(&attiny->lock);
+
+	ret = i2c_smbus_read_byte_data(attiny->client, REG_PRODUCT_NAME_LENGTH);
+	if (ret < 0) {
+		dev_err(attiny->dev,
+			"failed reading register PRODUCT_NAME_LENGTH\n");
+		goto out_err_read;
+	}
+	len = (uint8_t)ret;
+	if (len > 16) {
+		dev_err(attiny->dev,
+			"error with product name length (length read = %d)\n",
+			len);
+		goto out_err_read;
+	}
+
+	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_PRODUCT_NAME,
+					    (uint8_t)ret, tmp);
+	if (ret < 0) {
+		dev_err(attiny->dev, "failed reading register PRODUCT_NAME\n");
+		goto out_err_read;
+	}
+
+	mutex_unlock(&attiny->lock);
+
+	strncpy(str, tmp, len);
+	return (int)len;
+
+out_err_read:
+	mutex_unlock(&attiny->lock);
+	dev_err(attiny->dev, "failed retrieving product name\n");
+	return -EIO;
+}
+
+static int product_type_get(struct attiny *attiny, char *str)
+{
+	int ret;
+	uint8_t len;
+	char tmp[16];
+
+	mutex_lock(&attiny->lock);
+
+	ret = i2c_smbus_read_byte_data(attiny->client, REG_PRODUCT_TYPE_LENGTH);
+	if (ret < 0) {
+		dev_err(attiny->dev,
+			"failed reading register PRODUCT_TYPE_LENGTH\n");
+		goto out_err_read;
+	}
+	len = (uint8_t)ret;
+	if (len > 16) {
+		dev_err(attiny->dev,
+			"error with product type length (length read = %d)\n",
+			len);
+		goto out_err_read;
+	}
+
+	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_PRODUCT_TYPE,
+					    (uint8_t)ret, tmp);
+	if (ret < 0) {
+		dev_err(attiny->dev, "failed reading register PRODUCT_TYPE\n");
+		goto out_err_read;
+	}
+
+	mutex_unlock(&attiny->lock);
+
+	strncpy(str, tmp, len);
+	return (int)len;
+
+out_err_read:
+	mutex_unlock(&attiny->lock);
+	dev_err(attiny->dev, "failed retrieving product type\n");
+	return -EIO;
+}
+
+static int reg_feature1_get(struct attiny *attiny, reg_feature1_t *reg_feature1)
+{
+	int ret = pmic_lorix_read(attiny, REG_FEATURE1, &reg_feature1->raw);
+	if (ret < 0)
+		reg_feature1->raw = 0x00;
+
+	return ret;
+}
+
+static int reg_feature2_get(struct attiny *attiny, reg_feature2_t *reg_feature2)
+{
+	int ret = pmic_lorix_read(attiny, REG_FEATURE2, &reg_feature2->raw);
+	if (ret < 0)
+		reg_feature2->raw = 0x00;
+
+	return ret;
+}
+
+static ssize_t dev_version_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n", "1.2.0");
+}
+
+static ssize_t boot_state_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct attiny *attiny = dev_get_drvdata(dev);
+	uint8_t boot_state;
+
+	boot_state_get(attiny, &boot_state);
+	return sprintf(buf, "%d\n", boot_state);
+}
+
+static ssize_t boot_state_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct attiny *attiny = dev_get_drvdata(dev);
+	int inval;
+
+	sscanf(buf, "%du", &inval);
+	if (inval != 0) {
+		boot_state_clr(attiny);
+	}
+	return count;
+}
+
+static ssize_t fw_version_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	return sprintf(buf, "%s\n", cache->fw_ver);
+}
+
+static ssize_t hw_version_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	return sprintf(buf, "%s\n", cache->hw_ver);
+}
+
+static ssize_t product_name_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	return sprintf(buf, "%s\n", cache->name);
+}
+
+static ssize_t product_type_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	return sprintf(buf, "%s\n", cache->type);
+}
+
+static ssize_t serial_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	return sprintf(buf, "%s\n", cache->serial);
+}
+
+static int strcompare(const char *str1, const char *str2)
+{
+	int result;
+	size_t len1, len2;
+
+	len1 = strlen(str1);
+	len2 = strlen(str2);
+
+	if (len1 < len2) {
+		return -2;
+	} else if (len1 > len2) {
+		return 2;
+	}
+
+	result = strncmp(str1, str2, len1);
+	if (result < 0) {
+		return -1;
+	} else if (result > 0) {
+		return 1;
+	}
+
+	return 0;
+}
+
+struct hw_ver {
+	int major;
+	int minor;
+	int revision;
+	int bom;
+};
+
+static int parse_uint(const char *str, size_t len, int *result)
+{
+	int index;
+	char pointer[20];
+	long int res;
+	*result = -1;
+
+	for (index = 0; index < len && index < sizeof(pointer) - 1; index++) {
+		if (isdigit(str[index])) {
+			pointer[index] = str[index];
+		} else {
+			break;
+		}
+	}
+	if (index == sizeof(pointer) - 1 && isdigit(str[index])) {
+		return -ERANGE;
+	} else {
+		pointer[index] = '\0';
+	}
+
+	if (kstrtol(pointer, 10, &res)) {
+		return -EINVAL;
+	} else if (res < 0 || res > INT_MAX) {
+		return -ERANGE;
+	}
+	*result = res;
+	return index;
+}
+
+static int parse_hw_ver(const char *str, struct hw_ver *version)
+{
+	size_t len = strlen(str);
+	size_t i = 0;
+	long res;
+	char pointer[20];
+	if (len >= sizeof(pointer)) {
+		return -EINVAL;
+	}
+	version->major = -1;
+	version->minor = -1;
+	version->revision = -1;
+	version->bom = -1;
+
+	// major
+	if (i < len) {
+		if ((res = parse_uint(&str[i], len - i, &version->major)) < 0) {
+			return res;
+		}
+		i += res;
+	}
+
+	// point between major and minor
+	if (i < len && str[i++] != '.') {
+		return -EINVAL;
+	}
+	//minor
+	if (i < len) {
+		if ((res = parse_uint(&str[i], len - i, &version->minor)) < 0) {
+			return res;
+		}
+		i += res;
+	}
+	//revision
+	if (i < len) {
+		if (!isalpha(str[i]) ||
+		    (str[i + 1] != '\0' && !isdigit(str[i + 1]))) {
+			return -EINVAL;
+		}
+		version->revision = (int)(tolower(str[i++]) - 'a');
+	}
+	// BOM
+	if (i < len) {
+		if ((res = parse_uint(&str[i], len - i, &version->bom)) < 0) {
+			return res;
+		}
+		i += res;
+	}
+	return 0;
+}
+
+static inline int int_compare(int int1, int int2)
+{
+	if (int1 < int2) {
+		return -1;
+	} else if (int1 > int2) {
+		return 1;
+	} else {
+		return 0;
+	}
+}
+
+static int hw_ver_compare(struct hw_ver *ver1, struct hw_ver *ver2)
+{
+	int cmp;
+	// compare major
+	if ((cmp = int_compare(ver1->major, ver2->major))) {
+		return cmp;
+	}
+	// compare minor
+	if ((cmp = int_compare(ver1->minor, ver2->minor))) {
+		return cmp;
+	}
+	// compare revision
+	if ((cmp = int_compare((int)ver1->revision, (int)ver2->revision))) {
+		return cmp;
+	}
+	// compare bom
+	if ((cmp = int_compare(ver1->bom, ver2->bom))) {
+		return cmp;
+	}
+	return 0;
+}
+
+static ssize_t memory_ram_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+	if (!strcompare(cache->name, "LORIX One")) {
+		return sprintf(buf, "%d\n", 128 * 1024);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t memory_nand_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct hw_ver version;
+	attiny_cache_t *cache = ((struct attiny *)dev_get_drvdata(dev))->cache;
+
+	if (!strcompare(cache->name, "LORIX One") &&
+	    !parse_hw_ver(cache->hw_ver, &version)) {
+		struct hw_ver ver_512MB = {
+			.major = 1, .minor = 0, .revision = 3, .bom = 2
+		};
+		if (hw_ver_compare(&version, &ver_512MB) >= 0) {
+			return sprintf(buf, "%d\n", 512 * 1024);
+		} else {
+			return sprintf(buf, "%d\n", 256 * 1024);
+		}
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static DEVICE_ATTR(dev_version, S_IRUGO, dev_version_show, NULL);
+static DEVICE_ATTR(boot_state,
+		   (S_IWUSR | S_IRUSR | S_IWGRP | S_IRGRP | S_IROTH),
+		   boot_state_show, boot_state_store);
+static DEVICE_ATTR(fw_version, S_IRUGO, fw_version_show, NULL);
+static DEVICE_ATTR(hw_version, S_IRUGO, hw_version_show, NULL);
+static DEVICE_ATTR(product_name, S_IRUGO, product_name_show, NULL);
+static DEVICE_ATTR(product_type, S_IRUGO, product_type_show, NULL);
+static DEVICE_ATTR(serial, S_IRUGO, serial_show, NULL);
+static DEVICE_ATTR(mem_ram, S_IRUGO, memory_ram_show, NULL);
+static DEVICE_ATTR(mem_nand, S_IRUGO, memory_nand_show, NULL);
+static const struct attribute *machine_attrs[] = {
+	&dev_attr_dev_version.attr,  &dev_attr_serial.attr,
+	&dev_attr_boot_state.attr,   &dev_attr_fw_version.attr,
+	&dev_attr_hw_version.attr,   &dev_attr_product_name.attr,
+	&dev_attr_product_type.attr, &dev_attr_mem_ram.attr,
+	&dev_attr_mem_nand.attr,     NULL,
+};
+static const struct attribute_group machine_attr_group = {
+	.attrs = (struct attribute **)machine_attrs,
+};
+static struct class *product_class;
+
+static int pmic_lorix_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct attiny_platform_data *pdata = dev_get_platdata(&client->dev);
+	struct attiny *attiny;
+	attiny_cache_t *cache;
+	struct device *dev = &client->dev;
+	uint8_t boot_state;
+	int ret;
+	struct net_device *netif_dev;
+	bool eth0_found = false;
+
+	/* Right now device-tree probed devices don't get dma_mask set.
+	 * Since shared usb code relies on it, set it here for now.
+	 * Once we have dma capability bindings this can go away.
+	 */
+	ret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
+	if (ret)
+		return ret;
+
+	if (!i2c_check_functionality(client->adapter,
+				     I2C_FUNC_SMBUS_BYTE_DATA)) {
+		dev_err(dev, "SMBUS Word Data not Supported\n");
+		return -EIO;
+	}
+
+	// creating the driver data
+	attiny = devm_kzalloc(dev, sizeof(struct attiny), GFP_KERNEL);
+	if (!attiny) {
+		dev_err(dev, "Failed to allocate memory for driver data\n");
+		return -ENOMEM;
+	}
+
+	// creating the cache driver data
+	cache = devm_kzalloc(dev, sizeof(attiny_cache_t), GFP_KERNEL);
+	if (!cache) {
+		dev_err(dev,
+			"Failed to allocate memory for driver cache data\n");
+		return -ENOMEM;
+	}
+	attiny->cache = cache;
+
+	// assign driver data to device
+	dev_set_drvdata(dev, attiny);
+	attiny->client = client;
+	attiny->dev = dev;
+	attiny->id = id->driver_data;
+
+	// init the device lock
+	mutex_init(&attiny->lock);
+
+	if (pdata) {
+		pmic_lorix_devs[0].platform_data = &pdata->leds;
+		pmic_lorix_devs[0].pdata_size = sizeof(pdata->leds);
+	} else {
+		pmic_lorix_devs[0].platform_data = NULL;
+		pmic_lorix_devs[0].pdata_size = 0;
+	}
+	ret = mfd_add_devices(dev, -1,
+			      (const struct mfd_cell *)&pmic_lorix_devs, 1,
+			      NULL, 0, NULL);
+	if (ret < 0) {
+		dev_err(dev, "add mfd devices failed: %d\n", ret);
+		return ret;
+	}
+
+	// create product class which will contains the pmic driver access
+	product_class = class_create(THIS_MODULE, "product");
+	if (IS_ERR(product_class)) {
+		dev_err(dev, "pmic-lorix cant create class %s\n", "product");
+		ret = -ENODEV;
+		goto out_remove_mfd;
+	}
+
+	// create machine hierarchy
+	attiny->machine_dev =
+		device_create(product_class, dev, 0, attiny, "machine");
+	if (IS_ERR(attiny->machine_dev)) {
+		dev_err(dev, "failed to create device '%s_%s'\n", "product",
+			"machine");
+		ret = -ENODEV;
+		goto out_remove_class;
+	}
+
+	// create attribute group
+	ret = sysfs_create_group(&attiny->machine_dev->kobj,
+				 &machine_attr_group);
+	if (ret < 0) {
+		dev_err(dev, "failed to create sysfs attributes group\n");
+		goto out_remove_device;
+	}
+
+	// FW version, HW version and boot state work in all cases since revision 1.0c
+
+	// read FW version
+	ret = fw_version_get(attiny, cache->fw_ver);
+	if (ret < 0) {
+		dev_err(dev, "failed to retrieve FW version from pmic-lorix\n");
+		goto out_remove_all;
+	}
+
+	// read HW version
+	ret = hw_version_get(attiny, cache->hw_ver);
+	if (ret < 0) {
+		dev_err(dev, "failed to retrieve HW version from pmic-lorix\n");
+		goto out_remove_all;
+	}
+
+	// read bootstate
+	ret = boot_state_get(attiny, &boot_state);
+	if (ret < 0) {
+		dev_err(dev, "failed to retrieve boot_state from pmic-lorix\n");
+		goto out_remove_all;
+	}
+
+	// values by default
+	strcpy(cache->name, "LORIX One");
+	strcpy(cache->type, "EU868");
+
+	// test if features regs can be read
+	ret = reg_feature1_get(attiny, &cache->feature1);
+	if (ret < 0 || cache->feature1.bit.FEAT_LEGACY) {
+		cache->feature1.bit.FEAT_BOOT = 1;
+		cache->feature1.bit.FEAT_FW_VER = 1;
+		cache->feature1.bit.FEAT_HW_VER = 1;
+		cache->feature1.bit.FEAT_NAME = 0;
+		cache->feature1.bit.FEAT_TYPE = 0;
+		cache->feature1.bit.FEAT_PROG = 0;
+	}
+
+	// unused actually
+	ret = reg_feature2_get(attiny, &cache->feature2);
+
+	// read product name if possible
+	if (cache->feature1.bit.FEAT_NAME) {
+		ret = product_name_get(attiny, cache->name);
+		if (ret < 0) {
+			dev_err(dev,
+				"failed to retrieve product name from pmic-lorix\n");
+			goto out_remove_all;
+		}
+	}
+
+	// read product type if possible
+	if (cache->feature1.bit.FEAT_TYPE) {
+		ret = product_type_get(attiny, cache->type);
+		if (ret < 0) {
+			dev_err(dev,
+				"failed to retrieve product type from pmic-lorix\n");
+			goto out_remove_all;
+		}
+	}
+
+	/* manage the serial which is based on eth0 MAC address */
+	read_lock(&dev_base_lock);
+	for_each_netdev (&init_net, netif_dev) {
+		if (!strcmp(netif_dev->name, "eth0")) {
+			eth0_found = true;
+
+			sprintf(cache->serial, "%02x%02x%02xfffe%02x%02x%02x",
+				netif_dev->dev_addr[0], netif_dev->dev_addr[1],
+				netif_dev->dev_addr[2], netif_dev->dev_addr[3],
+				netif_dev->dev_addr[4], netif_dev->dev_addr[5]);
+		}
+	}
+	read_unlock(&dev_base_lock);
+
+	if (!eth0_found) {
+		dev_err(dev,
+			"eth0 interface not found, can't derive serial number from MAC address\n");
+		sprintf(cache->serial, "error");
+	}
+
+	// display machine info
+	dev_info(dev, "Product %s detected\n", cache->name);
+	dev_info(dev, "   Type: %s\n", cache->type);
+	dev_info(dev, " HW ver: %s\n", cache->hw_ver);
+	dev_info(dev, " FW ver: %s\n", cache->fw_ver);
+	if (eth0_found) {
+		dev_info(dev, " Serial: %s\n", cache->serial);
+	} else {
+		dev_err(dev, " Serial: error\n");
+	}
+
+	switch (boot_state) {
+	case 0x00:
+		dev_info(dev, "   Boot: 0x00 (normal mode)\n");
+		break;
+	case 0x01:
+		dev_info(dev, "   Boot: 0x01 (factory reset mode)\n");
+		break;
+	default:
+		dev_info(
+			dev,
+			"   Boot: 0x%02X (unknown mode), clearing boot state\n",
+			boot_state);
+		boot_state_clr(attiny);
+		break;
+	}
+
+	return 0;
+
+out_remove_all:
+	sysfs_remove_group(&attiny->machine_dev->kobj, &machine_attr_group);
+
+out_remove_device:
+	device_unregister(attiny->machine_dev);
+
+out_remove_class:
+	class_unregister(product_class);
+	class_destroy(product_class);
+
+out_remove_mfd:
+	mfd_remove_devices(dev);
+
+	return ret;
+}
+
+static int pmic_lorix_remove(struct i2c_client *client)
+{
+	struct attiny *attiny = dev_get_drvdata(&client->dev);
+	sysfs_remove_group(&attiny->machine_dev->kobj, &machine_attr_group);
+	device_unregister(attiny->machine_dev);
+	class_unregister(product_class);
+	class_destroy(product_class);
+	mfd_remove_devices(&client->dev);
+	return 0;
+}
+
+static const struct i2c_device_id pmic_lorix_id[] = { { "pmic-lorix", 0 }, {} };
+MODULE_DEVICE_TABLE(i2c, pmic_lorix_id);
+
+#ifdef CONFIG_OF
+static const struct of_device_id pmic_lorix_of_match[] = {
+	{
+		.compatible = "wifx,pmic-lorix",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, pmic_lorix_of_match);
+#endif
+
+static struct i2c_driver pmic_lorix_driver = {
+    .probe        = pmic_lorix_probe,
+    .remove        = pmic_lorix_remove,
+    .driver = {
+        .name    = "pmic-lorix",
+        .of_match_table = of_match_ptr(pmic_lorix_of_match),
+    },
+    .id_table     = pmic_lorix_id,
+};
+
+static int __init pmic_lorix_i2c_init(void)
+{
+	return i2c_add_driver(&pmic_lorix_driver);
+}
+/* init early so consumer devices can complete system boot */
+subsys_initcall(pmic_lorix_i2c_init);
+
+static void __exit pmic_lorix_i2c_exit(void)
+{
+	i2c_del_driver(&pmic_lorix_driver);
+}
+module_exit(pmic_lorix_i2c_exit);
+
+MODULE_AUTHOR("Yannick Lanz <yannick.lanz@wifx.net>");
+MODULE_DESCRIPTION("LORIX One PMIC-MFD Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c
index e93e8f980b47..6fb2596eae6c 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.c
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c
@@ -6,29 +6,30 @@
  */
 #include <linux/clk.h>
 #include <linux/clk/at91_pmc.h>
-#include <linux/module.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/gpio/consumer.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
-#include <linux/slab.h>
-#include <linux/device.h>
-#include <linux/dma-mapping.h>
+#include <linux/irq.h>
 #include <linux/list.h>
 #include <linux/mfd/syscon.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
-#include <linux/ctype.h>
+#include <linux/slab.h>
 #include <linux/usb.h>
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
-#include <linux/delay.h>
-#include <linux/of.h>
-#include <linux/irq.h>
-#include <linux/gpio/consumer.h>
 
 #include "atmel_usba_udc.h"
-#define USBA_VBUS_IRQFLAGS (IRQF_ONESHOT \
-			   | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING)
+#define USBA_VBUS_IRQFLAGS                                                     \
+	(IRQF_ONESHOT | IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING)
 
 #ifdef CONFIG_USB_GADGET_DEBUG_FS
 #include <linux/debugfs.h>
@@ -46,7 +47,7 @@ static int queue_dbg_open(struct inode *inode, struct file *file)
 	INIT_LIST_HEAD(queue_data);
 
 	spin_lock_irq(&ep->udc->lock);
-	list_for_each_entry(req, &ep->queue, queue) {
+	list_for_each_entry (req, &ep->queue, queue) {
 		req_copy = kmemdup(req, sizeof(*req_copy), GFP_ATOMIC);
 		if (!req_copy)
 			goto fail;
@@ -59,7 +60,7 @@ static int queue_dbg_open(struct inode *inode, struct file *file)
 
 fail:
 	spin_unlock_irq(&ep->udc->lock);
-	list_for_each_entry_safe(req, req_copy, queue_data, queue) {
+	list_for_each_entry_safe (req, req_copy, queue_data, queue) {
 		list_del(&req->queue);
 		kfree(req);
 	}
@@ -82,7 +83,7 @@ static int queue_dbg_open(struct inode *inode, struct file *file)
  * L/l: last transaction/not last transaction
  */
 static ssize_t queue_dbg_read(struct file *file, char __user *buf,
-		size_t nbytes, loff_t *ppos)
+			      size_t nbytes, loff_t *ppos)
 {
 	struct list_head *queue = file->private_data;
 	struct usba_request *req, *tmp_req;
@@ -93,17 +94,16 @@ static ssize_t queue_dbg_read(struct file *file, char __user *buf,
 		return -EFAULT;
 
 	inode_lock(file_inode(file));
-	list_for_each_entry_safe(req, tmp_req, queue, queue) {
+	list_for_each_entry_safe (req, tmp_req, queue, queue) {
 		len = snprintf(tmpbuf, sizeof(tmpbuf),
-				"%8p %08x %c%c%c %5d %c%c%c\n",
-				req->req.buf, req->req.length,
-				req->req.no_interrupt ? 'i' : 'I',
-				req->req.zero ? 'Z' : 'z',
-				req->req.short_not_ok ? 's' : 'S',
-				req->req.status,
-				req->submitted ? 'F' : 'f',
-				req->using_dma ? 'D' : 'd',
-				req->last_transaction ? 'L' : 'l');
+			       "%8p %08x %c%c%c %5d %c%c%c\n", req->req.buf,
+			       req->req.length,
+			       req->req.no_interrupt ? 'i' : 'I',
+			       req->req.zero ? 'Z' : 'z',
+			       req->req.short_not_ok ? 's' : 'S',
+			       req->req.status, req->submitted ? 'F' : 'f',
+			       req->using_dma ? 'D' : 'd',
+			       req->last_transaction ? 'L' : 'l');
 		len = min(len, sizeof(tmpbuf));
 		if (len > nbytes)
 			break;
@@ -129,7 +129,7 @@ static int queue_dbg_release(struct inode *inode, struct file *file)
 	struct list_head *queue_data = file->private_data;
 	struct usba_request *req, *tmp_req;
 
-	list_for_each_entry_safe(req, tmp_req, queue_data, queue) {
+	list_for_each_entry_safe (req, tmp_req, queue_data, queue) {
 		list_del(&req->queue);
 		kfree(req);
 	}
@@ -164,16 +164,15 @@ static int regs_dbg_open(struct inode *inode, struct file *file)
 	return ret;
 }
 
-static ssize_t regs_dbg_read(struct file *file, char __user *buf,
-		size_t nbytes, loff_t *ppos)
+static ssize_t regs_dbg_read(struct file *file, char __user *buf, size_t nbytes,
+			     loff_t *ppos)
 {
 	struct inode *inode = file_inode(file);
 	int ret;
 
 	inode_lock(inode);
-	ret = simple_read_from_buffer(buf, nbytes, ppos,
-			file->private_data,
-			file_inode(file)->i_size);
+	ret = simple_read_from_buffer(buf, nbytes, ppos, file->private_data,
+				      file_inode(file)->i_size);
 	inode_unlock(inode);
 
 	return ret;
@@ -186,23 +185,22 @@ static int regs_dbg_release(struct inode *inode, struct file *file)
 }
 
 static const struct file_operations queue_dbg_fops = {
-	.owner		= THIS_MODULE,
-	.open		= queue_dbg_open,
-	.llseek		= no_llseek,
-	.read		= queue_dbg_read,
-	.release	= queue_dbg_release,
+	.owner = THIS_MODULE,
+	.open = queue_dbg_open,
+	.llseek = no_llseek,
+	.read = queue_dbg_read,
+	.release = queue_dbg_release,
 };
 
 static const struct file_operations regs_dbg_fops = {
-	.owner		= THIS_MODULE,
-	.open		= regs_dbg_open,
-	.llseek		= generic_file_llseek,
-	.read		= regs_dbg_read,
-	.release	= regs_dbg_release,
+	.owner = THIS_MODULE,
+	.open = regs_dbg_open,
+	.llseek = generic_file_llseek,
+	.read = regs_dbg_read,
+	.release = regs_dbg_release,
 };
 
-static void usba_ep_init_debugfs(struct usba_udc *udc,
-		struct usba_ep *ep)
+static void usba_ep_init_debugfs(struct usba_udc *udc, struct usba_ep *ep)
 {
 	struct dentry *ep_root;
 
@@ -230,8 +228,8 @@ static void usba_init_debugfs(struct usba_udc *udc)
 	root = debugfs_create_dir(udc->gadget.name, usb_debug_root);
 	udc->debugfs_root = root;
 
-	regs_resource = platform_get_resource(udc->pdev, IORESOURCE_MEM,
-				CTRL_IOMEM_ID);
+	regs_resource =
+		platform_get_resource(udc->pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
 
 	if (regs_resource) {
 		debugfs_create_file_size("regs", 0400, root, udc,
@@ -249,24 +247,20 @@ static void usba_cleanup_debugfs(struct usba_udc *udc)
 }
 #else
 static inline void usba_ep_init_debugfs(struct usba_udc *udc,
-					 struct usba_ep *ep)
+					struct usba_ep *ep)
 {
-
 }
 
 static inline void usba_ep_cleanup_debugfs(struct usba_ep *ep)
 {
-
 }
 
 static inline void usba_init_debugfs(struct usba_udc *udc)
 {
-
 }
 
 static inline void usba_cleanup_debugfs(struct usba_udc *udc)
 {
-
 }
 #endif
 
@@ -279,45 +273,153 @@ MODULE_PARM_DESC(fifo_mode, "Endpoint configuration mode");
 
 /* mode 1 - fits in 8KB, generic max fifo configuration */
 static struct usba_fifo_cfg mode_1_cfg[] = {
-{ .hw_ep_num = 0, .fifo_size = 64,	.nr_banks = 1, },
-{ .hw_ep_num = 1, .fifo_size = 1024,	.nr_banks = 2, },
-{ .hw_ep_num = 2, .fifo_size = 1024,	.nr_banks = 1, },
-{ .hw_ep_num = 3, .fifo_size = 1024,	.nr_banks = 1, },
-{ .hw_ep_num = 4, .fifo_size = 1024,	.nr_banks = 1, },
-{ .hw_ep_num = 5, .fifo_size = 1024,	.nr_banks = 1, },
-{ .hw_ep_num = 6, .fifo_size = 1024,	.nr_banks = 1, },
+	{
+		.hw_ep_num = 0,
+		.fifo_size = 64,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 1,
+		.fifo_size = 1024,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 2,
+		.fifo_size = 1024,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 3,
+		.fifo_size = 1024,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 4,
+		.fifo_size = 1024,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 5,
+		.fifo_size = 1024,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 6,
+		.fifo_size = 1024,
+		.nr_banks = 1,
+	},
 };
 
 /* mode 2 - fits in 8KB, performance max fifo configuration */
 static struct usba_fifo_cfg mode_2_cfg[] = {
-{ .hw_ep_num = 0, .fifo_size = 64,	.nr_banks = 1, },
-{ .hw_ep_num = 1, .fifo_size = 1024,	.nr_banks = 3, },
-{ .hw_ep_num = 2, .fifo_size = 1024,	.nr_banks = 2, },
-{ .hw_ep_num = 3, .fifo_size = 1024,	.nr_banks = 2, },
+	{
+		.hw_ep_num = 0,
+		.fifo_size = 64,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 1,
+		.fifo_size = 1024,
+		.nr_banks = 3,
+	},
+	{
+		.hw_ep_num = 2,
+		.fifo_size = 1024,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 3,
+		.fifo_size = 1024,
+		.nr_banks = 2,
+	},
 };
 
 /* mode 3 - fits in 8KB, mixed fifo configuration */
 static struct usba_fifo_cfg mode_3_cfg[] = {
-{ .hw_ep_num = 0, .fifo_size = 64,	.nr_banks = 1, },
-{ .hw_ep_num = 1, .fifo_size = 1024,	.nr_banks = 2, },
-{ .hw_ep_num = 2, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 3, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 4, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 5, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 6, .fifo_size = 512,	.nr_banks = 2, },
+	{
+		.hw_ep_num = 0,
+		.fifo_size = 64,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 1,
+		.fifo_size = 1024,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 2,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 3,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 4,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 5,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 6,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
 };
 
 /* mode 4 - fits in 8KB, custom fifo configuration */
 static struct usba_fifo_cfg mode_4_cfg[] = {
-{ .hw_ep_num = 0, .fifo_size = 64,	.nr_banks = 1, },
-{ .hw_ep_num = 1, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 2, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 3, .fifo_size = 8,	.nr_banks = 2, },
-{ .hw_ep_num = 4, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 5, .fifo_size = 512,	.nr_banks = 2, },
-{ .hw_ep_num = 6, .fifo_size = 16,	.nr_banks = 2, },
-{ .hw_ep_num = 7, .fifo_size = 8,	.nr_banks = 2, },
-{ .hw_ep_num = 8, .fifo_size = 8,	.nr_banks = 2, },
+	{
+		.hw_ep_num = 0,
+		.fifo_size = 64,
+		.nr_banks = 1,
+	},
+	{
+		.hw_ep_num = 1,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 2,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 3,
+		.fifo_size = 8,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 4,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 5,
+		.fifo_size = 512,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 6,
+		.fifo_size = 16,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 7,
+		.fifo_size = 8,
+		.nr_banks = 2,
+	},
+	{
+		.hw_ep_num = 8,
+		.fifo_size = 8,
+		.nr_banks = 2,
+	},
 };
 /* Add additional configurations here */
 
@@ -387,6 +489,15 @@ static int vbus_is_present(struct usba_udc *udc)
 	return 1;
 }
 
+static int id_is_device(struct usba_udc *udc)
+{
+	if (gpio_is_valid(udc->id_pin))
+		return gpio_get_value(udc->id_pin);
+
+	/* No ID detection: Assume always device */
+	return 1;
+}
+
 static void toggle_bias(struct usba_udc *udc, int is_on)
 {
 	if (udc->errata && udc->errata->toggle_bias)
@@ -417,8 +528,8 @@ static void next_fifo_transaction(struct usba_ep *ep, struct usba_request *req)
 		req->last_transaction = 0;
 
 	DBG(DBG_QUEUE, "%s: submit_transaction, req %p (length %d)%s\n",
-		ep->ep.name, req, transaction_len,
-		req->last_transaction ? ", done" : "");
+	    ep->ep.name, req, transaction_len,
+	    req->last_transaction ? ", done" : "");
 
 	memcpy_toio(ep->fifo, req->req.buf + req->req.actual, transaction_len);
 	usba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);
@@ -427,8 +538,8 @@ static void next_fifo_transaction(struct usba_ep *ep, struct usba_request *req)
 
 static void submit_request(struct usba_ep *ep, struct usba_request *req)
 {
-	DBG(DBG_QUEUE, "%s: submit_request: req %p (length %d)\n",
-		ep->ep.name, req, req->req.length);
+	DBG(DBG_QUEUE, "%s: submit_request: req %p (length %d)\n", ep->ep.name,
+	    req, req->req.length);
 
 	req->req.actual = 0;
 	req->submitted = 1;
@@ -499,8 +610,7 @@ static void receive_data(struct usba_ep *ep)
 			usba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);
 			break;
 		}
-		req = list_entry(ep->queue.next,
-				 struct usba_request, queue);
+		req = list_entry(ep->queue.next, struct usba_request, queue);
 
 		bytecount = USBA_BFEXT(BYTE_COUNT, status);
 
@@ -511,8 +621,8 @@ static void receive_data(struct usba_ep *ep)
 			bytecount = req->req.length - req->req.actual;
 		}
 
-		memcpy_fromio(req->req.buf + req->req.actual,
-				ep->fifo, bytecount);
+		memcpy_fromio(req->req.buf + req->req.actual, ep->fifo,
+			      bytecount);
 		req->req.actual += bytecount;
 
 		usba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);
@@ -537,8 +647,8 @@ static void receive_data(struct usba_ep *ep)
 	}
 }
 
-static void
-request_complete(struct usba_ep *ep, struct usba_request *req, int status)
+static void request_complete(struct usba_ep *ep, struct usba_request *req,
+			     int status)
 {
 	struct usba_udc *udc = ep->udc;
 
@@ -550,28 +660,27 @@ request_complete(struct usba_ep *ep, struct usba_request *req, int status)
 	if (req->using_dma)
 		usb_gadget_unmap_request(&udc->gadget, &req->req, ep->is_in);
 
-	DBG(DBG_GADGET | DBG_REQ,
-		"%s: req %p complete: status %d, actual %u\n",
-		ep->ep.name, req, req->req.status, req->req.actual);
+	DBG(DBG_GADGET | DBG_REQ, "%s: req %p complete: status %d, actual %u\n",
+	    ep->ep.name, req, req->req.status, req->req.actual);
 
 	spin_unlock(&udc->lock);
 	usb_gadget_giveback_request(&ep->ep, &req->req);
 	spin_lock(&udc->lock);
 }
 
-static void
-request_complete_list(struct usba_ep *ep, struct list_head *list, int status)
+static void request_complete_list(struct usba_ep *ep, struct list_head *list,
+				  int status)
 {
 	struct usba_request *req, *tmp_req;
 
-	list_for_each_entry_safe(req, tmp_req, list, queue) {
+	list_for_each_entry_safe (req, tmp_req, list, queue) {
 		list_del_init(&req->queue);
 		request_complete(ep, req, status);
 	}
 }
 
-static int
-usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+static int usba_ep_enable(struct usb_ep *_ep,
+			  const struct usb_endpoint_descriptor *desc)
 {
 	struct usba_ep *ep = to_usba_ep(_ep);
 	struct usba_udc *udc = ep->udc;
@@ -582,11 +691,10 @@ usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 
 	maxpacket = usb_endpoint_maxp(desc);
 
-	if (((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != ep->index)
-			|| ep->index == 0
-			|| desc->bDescriptorType != USB_DT_ENDPOINT
-			|| maxpacket == 0
-			|| maxpacket > ep->fifo_size) {
+	if (((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) !=
+	     ep->index) ||
+	    ep->index == 0 || desc->bDescriptorType != USB_DT_ENDPOINT ||
+	    maxpacket == 0 || maxpacket > ep->fifo_size) {
 		DBG(DBG_ERR, "ep_enable: Invalid argument");
 		return -EINVAL;
 	}
@@ -594,8 +702,8 @@ usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	ep->is_isoc = 0;
 	ep->is_in = 0;
 
-	DBG(DBG_ERR, "%s: EPT_CFG = 0x%lx (maxpacket = %lu)\n",
-			ep->ep.name, ep->ept_cfg, maxpacket);
+	DBG(DBG_ERR, "%s: EPT_CFG = 0x%lx (maxpacket = %lu)\n", ep->ep.name,
+	    ep->ept_cfg, maxpacket);
 
 	if (usb_endpoint_dir_in(desc)) {
 		ep->is_in = 1;
@@ -609,7 +717,7 @@ usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	case USB_ENDPOINT_XFER_ISOC:
 		if (!ep->can_isoc) {
 			DBG(DBG_ERR, "ep_enable: %s is not isoc capable\n",
-					ep->ep.name);
+			    ep->ep.name);
 			return -EINVAL;
 		}
 
@@ -646,7 +754,7 @@ usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 		u32 ctrl;
 
 		usba_int_enb_set(udc, USBA_BF(EPT_INT, 1 << ep->index) |
-				      USBA_BF(DMA_INT, 1 << ep->index));
+					      USBA_BF(DMA_INT, 1 << ep->index));
 		ctrl = USBA_AUTO_VALID | USBA_INTDIS_DMA;
 		usba_ep_writel(ep, CTL_ENB, ctrl);
 	} else {
@@ -656,9 +764,9 @@ usba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	DBG(DBG_HW, "EPT_CFG%d after init: %#08lx\n", ep->index,
-			(unsigned long)usba_ep_readl(ep, CFG));
+	    (unsigned long)usba_ep_readl(ep, CFG));
 	DBG(DBG_HW, "INT_ENB after init: %#08lx\n",
-			(unsigned long)usba_int_enb_get(udc));
+	    (unsigned long)usba_int_enb_get(udc));
 
 	return 0;
 }
@@ -697,8 +805,8 @@ static int usba_ep_disable(struct usb_ep *_ep)
 	return 0;
 }
 
-static struct usb_request *
-usba_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+static struct usb_request *usba_ep_alloc_request(struct usb_ep *_ep,
+						 gfp_t gfp_flags)
 {
 	struct usba_request *req;
 
@@ -713,8 +821,7 @@ usba_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
 	return &req->req;
 }
 
-static void
-usba_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
+static void usba_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
 {
 	struct usba_request *req = to_usba_req(_req);
 
@@ -724,16 +831,15 @@ usba_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)
 }
 
 static int queue_dma(struct usba_udc *udc, struct usba_ep *ep,
-		struct usba_request *req, gfp_t gfp_flags)
+		     struct usba_request *req, gfp_t gfp_flags)
 {
 	unsigned long flags;
 	int ret;
 
-	DBG(DBG_DMA, "%s: req l/%u d/%pad %c%c%c\n",
-		ep->ep.name, req->req.length, &req->req.dma,
-		req->req.zero ? 'Z' : 'z',
-		req->req.short_not_ok ? 'S' : 's',
-		req->req.no_interrupt ? 'I' : 'i');
+	DBG(DBG_DMA, "%s: req l/%u d/%pad %c%c%c\n", ep->ep.name,
+	    req->req.length, &req->req.dma, req->req.zero ? 'Z' : 'z',
+	    req->req.short_not_ok ? 'S' : 's',
+	    req->req.no_interrupt ? 'I' : 'i');
 
 	if (req->req.length > 0x10000) {
 		/* Lengths from 0 to 65536 (inclusive) are supported */
@@ -746,9 +852,8 @@ static int queue_dma(struct usba_udc *udc, struct usba_ep *ep,
 		return ret;
 
 	req->using_dma = 1;
-	req->ctrl = USBA_BF(DMA_BUF_LEN, req->req.length)
-			| USBA_DMA_CH_EN | USBA_DMA_END_BUF_IE
-			| USBA_DMA_END_BUF_EN;
+	req->ctrl = USBA_BF(DMA_BUF_LEN, req->req.length) | USBA_DMA_CH_EN |
+		    USBA_DMA_END_BUF_IE | USBA_DMA_END_BUF_EN;
 
 	if (!ep->is_in)
 		req->ctrl |= USBA_DMA_END_TR_EN | USBA_DMA_END_TR_IE;
@@ -772,8 +877,8 @@ static int queue_dma(struct usba_udc *udc, struct usba_ep *ep,
 	return ret;
 }
 
-static int
-usba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+static int usba_ep_queue(struct usb_ep *_ep, struct usb_request *_req,
+			 gfp_t gfp_flags)
 {
 	struct usba_request *req = to_usba_req(_req);
 	struct usba_ep *ep = to_usba_ep(_ep);
@@ -782,7 +887,7 @@ usba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	int ret;
 
 	DBG(DBG_GADGET | DBG_QUEUE | DBG_REQ, "%s: queue req %p, len %u\n",
-			ep->ep.name, req, _req->length);
+	    ep->ep.name, req, _req->length);
 
 	if (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN ||
 	    !ep->ep.desc)
@@ -805,9 +910,8 @@ usba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 		list_add_tail(&req->queue, &ep->queue);
 
 		if ((!ep_is_control(ep) && ep->is_in) ||
-			(ep_is_control(ep)
-				&& (ep->state == DATA_STAGE_IN
-					|| ep->state == STATUS_STAGE_IN)))
+		    (ep_is_control(ep) && (ep->state == DATA_STAGE_IN ||
+					   ep->state == STATUS_STAGE_IN)))
 			usba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);
 		else
 			usba_ep_writel(ep, CTL_ENB, USBA_RX_BK_RDY);
@@ -818,8 +922,8 @@ usba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	return ret;
 }
 
-static void
-usba_update_req(struct usba_ep *ep, struct usba_request *req, u32 status)
+static void usba_update_req(struct usba_ep *ep, struct usba_request *req,
+			    u32 status)
 {
 	req->req.actual = req->req.length - USBA_BFEXT(DMA_BUF_LEN, status);
 }
@@ -864,12 +968,12 @@ static int usba_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
 	unsigned long flags;
 	u32 status;
 
-	DBG(DBG_GADGET | DBG_QUEUE, "ep_dequeue: %s, req %p\n",
-			ep->ep.name, _req);
+	DBG(DBG_GADGET | DBG_QUEUE, "ep_dequeue: %s, req %p\n", ep->ep.name,
+	    _req);
 
 	spin_lock_irqsave(&udc->lock, flags);
 
-	list_for_each_entry(req, &ep->queue, queue) {
+	list_for_each_entry (req, &ep->queue, queue) {
 		if (&req->req == _req)
 			break;
 	}
@@ -922,16 +1026,16 @@ static int usba_ep_set_halt(struct usb_ep *_ep, int value)
 	int ret = 0;
 
 	DBG(DBG_GADGET, "endpoint %s: %s HALT\n", ep->ep.name,
-			value ? "set" : "clear");
+	    value ? "set" : "clear");
 
 	if (!ep->ep.desc) {
 		DBG(DBG_ERR, "Attempted to halt uninitialized ep %s\n",
-				ep->ep.name);
+		    ep->ep.name);
 		return -ENODEV;
 	}
 	if (ep->is_isoc) {
 		DBG(DBG_ERR, "Attempted to halt isochronous ep %s\n",
-				ep->ep.name);
+		    ep->ep.name);
 		return -ENOTTY;
 	}
 
@@ -941,16 +1045,16 @@ static int usba_ep_set_halt(struct usb_ep *_ep, int value)
 	 * We can't halt IN endpoints while there are still data to be
 	 * transferred
 	 */
-	if (!list_empty(&ep->queue)
-			|| ((value && ep->is_in && (usba_ep_readl(ep, STA)
-					& USBA_BF(BUSY_BANKS, -1L))))) {
+	if (!list_empty(&ep->queue) ||
+	    ((value && ep->is_in &&
+	      (usba_ep_readl(ep, STA) & USBA_BF(BUSY_BANKS, -1L))))) {
 		ret = -EAGAIN;
 	} else {
 		if (value)
 			usba_ep_writel(ep, SET_STA, USBA_FORCE_STALL);
 		else
 			usba_ep_writel(ep, CLR_STA,
-					USBA_FORCE_STALL | USBA_TOGGLE_CLR);
+				       USBA_FORCE_STALL | USBA_TOGGLE_CLR);
 		usba_ep_readl(ep, STA);
 	}
 
@@ -975,15 +1079,15 @@ static void usba_ep_fifo_flush(struct usb_ep *_ep)
 }
 
 static const struct usb_ep_ops usba_ep_ops = {
-	.enable		= usba_ep_enable,
-	.disable	= usba_ep_disable,
-	.alloc_request	= usba_ep_alloc_request,
-	.free_request	= usba_ep_free_request,
-	.queue		= usba_ep_queue,
-	.dequeue	= usba_ep_dequeue,
-	.set_halt	= usba_ep_set_halt,
-	.fifo_status	= usba_ep_fifo_status,
-	.fifo_flush	= usba_ep_fifo_flush,
+	.enable = usba_ep_enable,
+	.disable = usba_ep_disable,
+	.alloc_request = usba_ep_alloc_request,
+	.free_request = usba_ep_free_request,
+	.queue = usba_ep_queue,
+	.dequeue = usba_ep_dequeue,
+	.set_halt = usba_ep_set_halt,
+	.fifo_status = usba_ep_fifo_status,
+	.fifo_flush = usba_ep_fifo_flush,
 };
 
 static int usba_udc_get_frame(struct usb_gadget *gadget)
@@ -1011,8 +1115,8 @@ static int usba_udc_wakeup(struct usb_gadget *gadget)
 	return ret;
 }
 
-static int
-usba_udc_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)
+static int usba_udc_set_selfpowered(struct usb_gadget *gadget,
+				    int is_selfpowered)
 {
 	struct usba_udc *udc = to_usba_udc(gadget);
 	unsigned long flags;
@@ -1030,18 +1134,19 @@ usba_udc_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)
 
 static int atmel_usba_pullup(struct usb_gadget *gadget, int is_on);
 static int atmel_usba_start(struct usb_gadget *gadget,
-		struct usb_gadget_driver *driver);
+			    struct usb_gadget_driver *driver);
 static int atmel_usba_stop(struct usb_gadget *gadget);
 
-static struct usb_ep *atmel_usba_match_ep(struct usb_gadget *gadget,
-				struct usb_endpoint_descriptor	*desc,
-				struct usb_ss_ep_comp_descriptor *ep_comp)
+static struct usb_ep *
+atmel_usba_match_ep(struct usb_gadget *gadget,
+		    struct usb_endpoint_descriptor *desc,
+		    struct usb_ss_ep_comp_descriptor *ep_comp)
 {
-	struct usb_ep	*_ep;
+	struct usb_ep *_ep;
 	struct usba_ep *ep;
 
 	/* Look at endpoints until an unclaimed one looks usable */
-	list_for_each_entry(_ep, &gadget->ep_list, ep_list) {
+	list_for_each_entry (_ep, &gadget->ep_list, ep_list) {
 		if (usb_gadget_ep_match_desc(gadget, _ep, desc, ep_comp))
 			goto found_ep;
 	}
@@ -1073,11 +1178,11 @@ static struct usb_ep *atmel_usba_match_ep(struct usb_gadget *gadget,
 
 		case USB_ENDPOINT_XFER_INT:
 			if (desc->wMaxPacketSize == 0)
-				ep->fifo_size =
-				    roundup_pow_of_two(_ep->maxpacket_limit);
+				ep->fifo_size = roundup_pow_of_two(
+					_ep->maxpacket_limit);
 			else
-				ep->fifo_size =
-				    roundup_pow_of_two(le16_to_cpu(desc->wMaxPacketSize));
+				ep->fifo_size = roundup_pow_of_two(
+					le16_to_cpu(desc->wMaxPacketSize));
 			if (ep->udc->ep_prealloc)
 				ep->nr_banks = 1;
 			break;
@@ -1087,7 +1192,7 @@ static struct usb_ep *atmel_usba_match_ep(struct usb_gadget *gadget,
 		usb_ep_set_maxpacket_limit(&ep->ep, ep->fifo_size);
 
 		/* Generate ept_cfg basd on FIFO size and number of banks */
-		if (ep->fifo_size  <= 8)
+		if (ep->fifo_size <= 8)
 			ep->ept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);
 		else
 			/* LSB is bit 1, not 0 */
@@ -1101,13 +1206,13 @@ static struct usb_ep *atmel_usba_match_ep(struct usb_gadget *gadget,
 }
 
 static const struct usb_gadget_ops usba_udc_ops = {
-	.get_frame		= usba_udc_get_frame,
-	.wakeup			= usba_udc_wakeup,
-	.set_selfpowered	= usba_udc_set_selfpowered,
-	.pullup			= atmel_usba_pullup,
-	.udc_start		= atmel_usba_start,
-	.udc_stop		= atmel_usba_stop,
-	.match_ep		= atmel_usba_match_ep,
+	.get_frame = usba_udc_get_frame,
+	.wakeup = usba_udc_wakeup,
+	.set_selfpowered = usba_udc_set_selfpowered,
+	.pullup = atmel_usba_pullup,
+	.udc_start = atmel_usba_start,
+	.udc_stop = atmel_usba_stop,
+	.match_ep = atmel_usba_match_ep,
 };
 
 static struct usb_endpoint_descriptor usba_ep0_desc = {
@@ -1121,9 +1226,9 @@ static struct usb_endpoint_descriptor usba_ep0_desc = {
 };
 
 static const struct usb_gadget usba_gadget_template = {
-	.ops		= &usba_udc_ops,
-	.max_speed	= USB_SPEED_HIGH,
-	.name		= "atmel_usba_udc",
+	.ops = &usba_udc_ops,
+	.max_speed = USB_SPEED_HIGH,
+	.name = "atmel_usba_udc",
 };
 
 /*
@@ -1137,7 +1242,7 @@ static void reset_all_endpoints(struct usba_udc *udc)
 	usba_writel(udc, EPT_RST, ~0UL);
 
 	ep = to_usba_ep(udc->gadget.ep0);
-	list_for_each_entry_safe(req, tmp_req, &ep->queue, queue) {
+	list_for_each_entry_safe (req, tmp_req, &ep->queue, queue) {
 		list_del_init(&req->queue);
 		request_complete(ep, req, -ECONNRESET);
 	}
@@ -1158,8 +1263,8 @@ static struct usba_ep *get_ep_by_addr(struct usba_udc *udc, u16 wIndex)
 		bEndpointAddress = ep->ep.desc->bEndpointAddress;
 		if ((wIndex ^ bEndpointAddress) & USB_DIR_IN)
 			continue;
-		if ((bEndpointAddress & USB_ENDPOINT_NUMBER_MASK)
-				== (wIndex & USB_ENDPOINT_NUMBER_MASK))
+		if ((bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) ==
+		    (wIndex & USB_ENDPOINT_NUMBER_MASK))
 			return ep;
 	}
 
@@ -1200,8 +1305,8 @@ static int do_test_mode(struct usba_udc *udc)
 		/* JJKKJJKK * 8 */
 		0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
 		/* JJJJJJJKKKKKKK * 8 */
-		0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
-		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+		0xFF, 0xFF,
 		/* JJJJJJJK * 8 */
 		0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD,
 		/* {JKKKKKKK * 10}, JK */
@@ -1234,12 +1339,12 @@ static int do_test_mode(struct usba_udc *udc)
 		 */
 		ep = &udc->usba_ep[0];
 		usba_writel(udc, TST,
-				USBA_BF(SPEED_CFG, USBA_SPEED_CFG_FORCE_HIGH));
+			    USBA_BF(SPEED_CFG, USBA_SPEED_CFG_FORCE_HIGH));
 		usba_ep_writel(ep, CFG,
-				USBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)
-				| USBA_EPT_DIR_IN
-				| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)
-				| USBA_BF(BK_NUMBER, 1));
+			       USBA_BF(EPT_SIZE, USBA_EPT_SIZE_64) |
+				       USBA_EPT_DIR_IN |
+				       USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK) |
+				       USBA_BF(BK_NUMBER, 1));
 		if (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {
 			set_protocol_stall(udc, ep);
 			dev_err(dev, "Test_SE0_NAK: ep0 not mapped\n");
@@ -1252,10 +1357,10 @@ static int do_test_mode(struct usba_udc *udc)
 		/* Test_Packet */
 		ep = &udc->usba_ep[0];
 		usba_ep_writel(ep, CFG,
-				USBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)
-				| USBA_EPT_DIR_IN
-				| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)
-				| USBA_BF(BK_NUMBER, 1));
+			       USBA_BF(EPT_SIZE, USBA_EPT_SIZE_64) |
+				       USBA_EPT_DIR_IN |
+				       USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK) |
+				       USBA_BF(BK_NUMBER, 1));
 		if (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {
 			set_protocol_stall(udc, ep);
 			dev_err(dev, "Test_Packet: ep0 not mapped\n");
@@ -1263,7 +1368,7 @@ static int do_test_mode(struct usba_udc *udc)
 			usba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);
 			usba_writel(udc, TST, USBA_TST_PKT_MODE);
 			memcpy_toio(ep->fifo, test_packet_buffer,
-					sizeof(test_packet_buffer));
+				    sizeof(test_packet_buffer));
 			usba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);
 			dev_info(dev, "Entering Test_Packet mode...\n");
 		}
@@ -1299,7 +1404,7 @@ static inline bool feature_is_ep_halt(struct usb_ctrlrequest *crq)
 }
 
 static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
-		struct usb_ctrlrequest *crq)
+			    struct usb_ctrlrequest *crq)
 {
 	int retval = 0;
 
@@ -1309,11 +1414,11 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 
 		if (crq->bRequestType == (USB_DIR_IN | USB_RECIP_DEVICE)) {
 			status = cpu_to_le16(udc->devstatus);
-		} else if (crq->bRequestType
-				== (USB_DIR_IN | USB_RECIP_INTERFACE)) {
+		} else if (crq->bRequestType ==
+			   (USB_DIR_IN | USB_RECIP_INTERFACE)) {
 			status = cpu_to_le16(0);
-		} else if (crq->bRequestType
-				== (USB_DIR_IN | USB_RECIP_ENDPOINT)) {
+		} else if (crq->bRequestType ==
+			   (USB_DIR_IN | USB_RECIP_ENDPOINT)) {
 			struct usba_ep *target;
 
 			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
@@ -1338,16 +1443,16 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 	case USB_REQ_CLEAR_FEATURE: {
 		if (crq->bRequestType == USB_RECIP_DEVICE) {
 			if (feature_is_dev_remote_wakeup(crq))
-				udc->devstatus
-					&= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+				udc->devstatus &=
+					~(1 << USB_DEVICE_REMOTE_WAKEUP);
 			else
 				/* Can't CLEAR_FEATURE TEST_MODE */
 				goto stall;
 		} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
 			struct usba_ep *target;
 
-			if (crq->wLength != cpu_to_le16(0)
-					|| !feature_is_ep_halt(crq))
+			if (crq->wLength != cpu_to_le16(0) ||
+			    !feature_is_ep_halt(crq))
 				goto stall;
 			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
 			if (!target)
@@ -1356,7 +1461,7 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 			usba_ep_writel(target, CLR_STA, USBA_FORCE_STALL);
 			if (target->index != 0)
 				usba_ep_writel(target, CLR_STA,
-						USBA_TOGGLE_CLR);
+					       USBA_TOGGLE_CLR);
 		} else {
 			goto delegate;
 		}
@@ -1380,8 +1485,8 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 		} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {
 			struct usba_ep *target;
 
-			if (crq->wLength != cpu_to_le16(0)
-					|| !feature_is_ep_halt(crq))
+			if (crq->wLength != cpu_to_le16(0) ||
+			    !feature_is_ep_halt(crq))
 				goto stall;
 
 			target = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));
@@ -1406,7 +1511,7 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 		break;
 
 	default:
-delegate:
+	delegate:
 		spin_unlock(&udc->lock);
 		retval = udc->driver->setup(&udc->gadget, crq);
 		spin_lock(&udc->lock);
@@ -1416,10 +1521,10 @@ static int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,
 
 stall:
 	pr_err("udc: %s: Invalid setup request: %02x.%02x v%04x i%04x l%d, "
-		"halting endpoint...\n",
-		ep->ep.name, crq->bRequestType, crq->bRequest,
-		le16_to_cpu(crq->wValue), le16_to_cpu(crq->wIndex),
-		le16_to_cpu(crq->wLength));
+	       "halting endpoint...\n",
+	       ep->ep.name, crq->bRequestType, crq->bRequest,
+	       le16_to_cpu(crq->wValue), le16_to_cpu(crq->wIndex),
+	       le16_to_cpu(crq->wLength));
 	set_protocol_stall(udc, ep);
 	return -1;
 }
@@ -1434,13 +1539,12 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 	epstatus = usba_ep_readl(ep, STA);
 	epctrl = usba_ep_readl(ep, CTL);
 
-	DBG(DBG_INT, "%s [%d]: s/%08x c/%08x\n",
-			ep->ep.name, ep->state, epstatus, epctrl);
+	DBG(DBG_INT, "%s [%d]: s/%08x c/%08x\n", ep->ep.name, ep->state,
+	    epstatus, epctrl);
 
 	req = NULL;
 	if (!list_empty(&ep->queue))
-		req = list_entry(ep->queue.next,
-				 struct usba_request, queue);
+		req = list_entry(ep->queue.next, struct usba_request, queue);
 
 	if ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {
 		if (req->submitted)
@@ -1465,8 +1569,8 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 			break;
 		case STATUS_STAGE_ADDR:
 			/* Activate our new address */
-			usba_writel(udc, CTRL, (usba_readl(udc, CTRL)
-						| USBA_FADDR_EN));
+			usba_writel(udc, CTRL,
+				    (usba_readl(udc, CTRL) | USBA_FADDR_EN));
 			usba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);
 			ep->state = WAIT_FOR_SETUP;
 			break;
@@ -1487,8 +1591,8 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 			break;
 		default:
 			pr_err("udc: %s: TXCOMP: Invalid endpoint state %d, "
-				"halting endpoint...\n",
-				ep->ep.name, ep->state);
+			       "halting endpoint...\n",
+			       ep->ep.name, ep->state);
 			set_protocol_stall(udc, ep);
 			break;
 		}
@@ -1516,8 +1620,8 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 			usba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);
 			usba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);
 			pr_err("udc: %s: RXRDY: Invalid endpoint state %d, "
-				"halting endpoint...\n",
-				ep->ep.name, ep->state);
+			       "halting endpoint...\n",
+			       ep->ep.name, ep->state);
 			set_protocol_stall(udc, ep);
 			break;
 		}
@@ -1545,8 +1649,8 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 			 * packets arrive.  Just pretend we received
 			 * the status packet.
 			 */
-			if (ep->state == STATUS_STAGE_OUT
-					|| ep->state == STATUS_STAGE_IN) {
+			if (ep->state == STATUS_STAGE_OUT ||
+			    ep->state == STATUS_STAGE_IN) {
 				usba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);
 				status = 0;
 			}
@@ -1602,8 +1706,8 @@ static void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)
 		}
 
 		DBG(DBG_BUS, "req %02x.%02x, length %d, state %d, ret %d\n",
-			crq.crq.bRequestType, crq.crq.bRequest,
-			le16_to_cpu(crq.crq.wLength), ep->state, ret);
+		    crq.crq.bRequestType, crq.crq.bRequest,
+		    le16_to_cpu(crq.crq.wLength), ep->state, ret);
 
 		if (ret < 0) {
 			/* Let the host know that we failed */
@@ -1636,10 +1740,8 @@ static void usba_ep_irq(struct usba_udc *udc, struct usba_ep *ep)
 
 		if (req->using_dma) {
 			/* Send a zero-length packet */
-			usba_ep_writel(ep, SET_STA,
-					USBA_TX_PK_RDY);
-			usba_ep_writel(ep, CTL_DIS,
-					USBA_TX_PK_RDY);
+			usba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);
+			usba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);
 			list_del_init(&req->queue);
 			submit_next_request(ep);
 			request_complete(ep, req, 0);
@@ -1682,8 +1784,8 @@ static void usba_dma_irq(struct usba_udc *udc, struct usba_ep *ep)
 		dev_err(&udc->pdev->dev,
 			"DMA_CH_EN is set after transfer is finished!\n");
 		dev_err(&udc->pdev->dev,
-			"status=%#08x, pending=%#08x, control=%#08x\n",
-			status, pending, control);
+			"status=%#08x, pending=%#08x, control=%#08x\n", status,
+			pending, control);
 
 		/*
 		 * try to pretend nothing happened. We might have to
@@ -1722,7 +1824,7 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 	DBG(DBG_INT, "irq, status=%#08x\n", status);
 
 	if (status & USBA_DET_SUSPEND) {
-		usba_writel(udc, INT_CLR, USBA_DET_SUSPEND|USBA_WAKE_UP);
+		usba_writel(udc, INT_CLR, USBA_DET_SUSPEND | USBA_WAKE_UP);
 		usba_int_enb_set(udc, USBA_WAKE_UP);
 		usba_int_enb_clear(udc, USBA_DET_SUSPEND);
 		udc->suspended = true;
@@ -1730,8 +1832,8 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 		udc->bias_pulse_needed = true;
 		stop_clock(udc);
 		DBG(DBG_BUS, "Suspend detected\n");
-		if (udc->gadget.speed != USB_SPEED_UNKNOWN
-				&& udc->driver && udc->driver->suspend) {
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN && udc->driver &&
+		    udc->driver->suspend) {
 			spin_unlock(&udc->lock);
 			udc->driver->suspend(&udc->gadget);
 			spin_lock(&udc->lock);
@@ -1752,8 +1854,8 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 		usba_int_enb_set(udc, USBA_DET_SUSPEND);
 		generate_bias_pulse(udc);
 		DBG(DBG_BUS, "Resume detected\n");
-		if (udc->gadget.speed != USB_SPEED_UNKNOWN
-				&& udc->driver && udc->driver->resume) {
+		if (udc->gadget.speed != USB_SPEED_UNKNOWN && udc->driver &&
+		    udc->driver->resume) {
 			spin_unlock(&udc->lock);
 			udc->driver->resume(&udc->gadget);
 			spin_lock(&udc->lock);
@@ -1791,8 +1893,8 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 		int i;
 
 		usba_writel(udc, INT_CLR,
-			USBA_END_OF_RESET|USBA_END_OF_RESUME
-			|USBA_DET_SUSPEND|USBA_WAKE_UP);
+			    USBA_END_OF_RESET | USBA_END_OF_RESUME |
+				    USBA_DET_SUSPEND | USBA_WAKE_UP);
 		generate_bias_pulse(udc);
 		reset_all_endpoints(udc);
 
@@ -1814,18 +1916,17 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 		ep0->ep.desc = &usba_ep0_desc;
 		ep0->state = WAIT_FOR_SETUP;
 		usba_ep_writel(ep0, CFG,
-				(USBA_BF(EPT_SIZE, EP0_EPT_SIZE)
-				| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL)
-				| USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE)));
-		usba_ep_writel(ep0, CTL_ENB,
-				USBA_EPT_ENABLE | USBA_RX_SETUP);
+			       (USBA_BF(EPT_SIZE, EP0_EPT_SIZE) |
+				USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL) |
+				USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE)));
+		usba_ep_writel(ep0, CTL_ENB, USBA_EPT_ENABLE | USBA_RX_SETUP);
 
 		/* If we get reset while suspended... */
 		udc->suspended = false;
 		usba_int_enb_clear(udc, USBA_WAKE_UP);
 
-		usba_int_enb_set(udc, USBA_BF(EPT_INT, 1) |
-				      USBA_DET_SUSPEND | USBA_END_OF_RESUME);
+		usba_int_enb_set(udc, USBA_BF(EPT_INT, 1) | USBA_DET_SUSPEND |
+					      USBA_END_OF_RESUME);
 
 		/*
 		 * Unclear why we hit this irregularly, e.g. in usbtest,
@@ -1842,7 +1943,8 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 				usba_ep_writel(ep, CFG, ep->ept_cfg);
 				if (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED))
 					dev_err(&udc->pdev->dev,
-						"ODD: EP%d configuration is invalid!\n", i);
+						"ODD: EP%d configuration is invalid!\n",
+						i);
 			}
 		}
 	}
@@ -1904,14 +2006,16 @@ static int usba_start(struct usba_udc *udc)
 		return 0;
 
 	spin_lock_irqsave(&udc->lock, flags);
+	dev_dbg(&udc->pdev->dev, "Enable bias\n");
 	toggle_bias(udc, 1);
+	dev_dbg(&udc->pdev->dev, "Switch to device\n");
 	usba_writel(udc, CTRL, USBA_ENABLE_MASK);
 	/* Clear all requested and pending interrupts... */
 	usba_writel(udc, INT_ENB, 0);
 	udc->int_enb_cache = 0;
 	usba_writel(udc, INT_CLR,
-		USBA_END_OF_RESET|USBA_END_OF_RESUME
-		|USBA_DET_SUSPEND|USBA_WAKE_UP);
+		    USBA_END_OF_RESET | USBA_END_OF_RESUME | USBA_DET_SUSPEND |
+			    USBA_WAKE_UP);
 	/* ...and enable just 'reset' IRQ to get us started */
 	usba_int_enb_set(udc, USBA_END_OF_RESET);
 	spin_unlock_irqrestore(&udc->lock, flags);
@@ -1931,7 +2035,9 @@ static void usba_stop(struct usba_udc *udc)
 	reset_all_endpoints(udc);
 
 	/* This will also disable the DP pullup */
+	dev_dbg(&udc->pdev->dev, "Disable bias\n");
 	toggle_bias(udc, 0);
+	dev_dbg(&udc->pdev->dev, "Switch to host\n");
 	usba_writel(udc, CTRL, USBA_DISABLE_MASK);
 	spin_unlock_irqrestore(&udc->lock, flags);
 
@@ -1949,8 +2055,13 @@ static irqreturn_t usba_vbus_irq_thread(int irq, void *devid)
 	mutex_lock(&udc->vbus_mutex);
 
 	vbus = vbus_is_present(udc);
+	dev_dbg(&udc->pdev->dev, "VBUS irq: %s\n",
+		vbus ? "power on" : "power off");
+	/* test level of ID pin */
+	dev_dbg(&udc->pdev->dev, "ID value: %s\n",
+		id_is_device(udc) ? "device" : "host");
 	if (vbus != udc->vbus_prev) {
-		if (vbus) {
+		if (vbus && id_is_device(udc)) {
 			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 			usba_start(udc);
 		} else {
@@ -1987,11 +2098,12 @@ static int atmel_usba_pullup(struct usb_gadget *gadget, int is_on)
 }
 
 static int atmel_usba_start(struct usb_gadget *gadget,
-		struct usb_gadget_driver *driver)
+			    struct usb_gadget_driver *driver)
 {
 	int ret;
 	struct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);
 	unsigned long flags;
+	int id;
 
 	spin_lock_irqsave(&udc->lock, flags);
 	udc->devstatus = 1 << USB_DEVICE_SELF_POWERED;
@@ -2005,7 +2117,19 @@ static int atmel_usba_start(struct usb_gadget *gadget,
 
 	/* If Vbus is present, enable the controller and wait for reset */
 	udc->vbus_prev = vbus_is_present(udc);
-	if (udc->vbus_prev) {
+
+	/* Check ID pin status */
+	if (gpio_is_valid(udc->id_pin)) {
+		id = id_is_device(udc);
+		dev_dbg(&udc->pdev->dev, "ID value: %s\n",
+			id ? "device" : "host");
+	} else {
+		/* ID pin not valid, assuming device */
+		id = 1;
+	}
+
+	/* Only activate device mode if VBUS is present and ID is device */
+	if (udc->vbus_prev && id) {
 		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
 		ret = usba_start(udc);
 		if (ret)
@@ -2065,51 +2189,51 @@ static const struct usba_udc_errata at91sam9g45_errata = {
 };
 
 static const struct usba_ep_config ep_config_sam9[] __initconst = {
-	{ .nr_banks = 1 },				/* ep 0 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 1 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 2 */
-	{ .nr_banks = 3, .can_dma = 1 },		/* ep 3 */
-	{ .nr_banks = 3, .can_dma = 1 },		/* ep 4 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 5 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 6 */
+	{ .nr_banks = 1 }, /* ep 0 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 1 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 2 */
+	{ .nr_banks = 3, .can_dma = 1 }, /* ep 3 */
+	{ .nr_banks = 3, .can_dma = 1 }, /* ep 4 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 5 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 6 */
 };
 
 static const struct usba_ep_config ep_config_sama5[] __initconst = {
-	{ .nr_banks = 1 },				/* ep 0 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 1 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 2 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 3 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 4 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 5 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 6 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 7 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 8 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 9 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 10 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 11 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 12 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 13 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 14 */
-	{ .nr_banks = 2, .can_isoc = 1 },		/* ep 15 */
+	{ .nr_banks = 1 }, /* ep 0 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 1 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 2 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 3 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 4 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 5 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 6 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 7 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 8 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 9 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 10 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 11 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 12 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 13 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 14 */
+	{ .nr_banks = 2, .can_isoc = 1 }, /* ep 15 */
 };
 
 static const struct usba_ep_config ep_config_sama7[] __initconst = {
-	{ .nr_banks = 1 },				/* ep 0 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 1 */
-	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 },	/* ep 2 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 3 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 4 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 5 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 6 */
-	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 },	/* ep 7 */
-	{ .nr_banks = 1 },				/* ep 8 */
-	{ .nr_banks = 1 },				/* ep 9 */
-	{ .nr_banks = 1 },				/* ep 10 */
-	{ .nr_banks = 1 },				/* ep 11 */
-	{ .nr_banks = 1 },				/* ep 12 */
-	{ .nr_banks = 1 },				/* ep 13 */
-	{ .nr_banks = 1 },				/* ep 14 */
-	{ .nr_banks = 1 },				/* ep 15 */
+	{ .nr_banks = 1 }, /* ep 0 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 1 */
+	{ .nr_banks = 3, .can_dma = 1, .can_isoc = 1 }, /* ep 2 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 3 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 4 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 5 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 6 */
+	{ .nr_banks = 2, .can_dma = 1, .can_isoc = 1 }, /* ep 7 */
+	{ .nr_banks = 1 }, /* ep 8 */
+	{ .nr_banks = 1 }, /* ep 9 */
+	{ .nr_banks = 1 }, /* ep 10 */
+	{ .nr_banks = 1 }, /* ep 11 */
+	{ .nr_banks = 1 }, /* ep 12 */
+	{ .nr_banks = 1 }, /* ep 13 */
+	{ .nr_banks = 1 }, /* ep 14 */
+	{ .nr_banks = 1 }, /* ep 15 */
 };
 
 static const struct usba_udc_config udc_at91sam9rl_cfg = {
@@ -2162,9 +2286,10 @@ static const struct of_device_id atmel_pmc_dt_ids[] = {
 	{ /* sentinel */ }
 };
 
-static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,
-						    struct usba_udc *udc)
+static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
+					 struct usba_udc *udc)
 {
+	enum of_gpio_flags flags;
 	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *match;
 	struct device_node *pp;
@@ -2195,8 +2320,21 @@ static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,
 
 	udc->num_ep = 0;
 
-	udc->vbus_pin = devm_gpiod_get_optional(&pdev->dev, "atmel,vbus",
-						GPIOD_IN);
+	udc->vbus_pin =
+		devm_gpiod_get_optional(&pdev->dev, "atmel,vbus", GPIOD_IN);
+	if (IS_ERR(udc->vbus_pin)) {
+		ret = PTR_ERR(udc->vbus_pin);
+		dev_err(&pdev->dev, "unable to claim gpio \"vbus\": %d\n", ret);
+	}
+
+	udc->id_pin = of_get_named_gpio_flags(np, "atmel,id-gpio", 0, &flags);
+
+	if (gpio_is_valid(udc->id_pin)) {
+		dev_dbg(&udc->pdev->dev, "id pin: %s\n",
+			id_is_device(udc) ? "device" : "host");
+	} else {
+		dev_dbg(&udc->pdev->dev, "id pin not given or invalid\n");
+	}
 
 	if (fifo_mode == 0) {
 		udc->num_ep = udc_config->num_ep;
@@ -2274,12 +2412,13 @@ static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,
 			 * Generate ept_cfg based on FIFO size and
 			 * banks number
 			 */
-			if (ep->fifo_size  <= 8)
-				ep->ept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);
+			if (ep->fifo_size <= 8)
+				ep->ept_cfg =
+					USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);
 			else
 				/* LSB is bit 1, not 0 */
-				ep->ept_cfg =
-				  USBA_BF(EPT_SIZE, fls(ep->fifo_size - 1) - 3);
+				ep->ept_cfg = USBA_BF(
+					EPT_SIZE, fls(ep->fifo_size - 1) - 3);
 
 			ep->ept_cfg |= USBA_BF(BK_NUMBER, ep->nr_banks);
 		}
@@ -2312,6 +2451,8 @@ static int usba_udc_probe(struct platform_device *pdev)
 	if (!udc)
 		return -ENOMEM;
 
+	dev_dbg(&pdev->dev, "Driver probing\n");
+
 	udc->gadget = usba_gadget_template;
 	INIT_LIST_HEAD(&udc->gadget.ep_list);
 
@@ -2319,8 +2460,8 @@ static int usba_udc_probe(struct platform_device *pdev)
 	udc->regs = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(udc->regs))
 		return PTR_ERR(udc->regs);
-	dev_info(&pdev->dev, "MMIO registers at %pR mapped at %p\n",
-		 res, udc->regs);
+	dev_info(&pdev->dev, "MMIO registers at %pR mapped at %p\n", res,
+		 udc->regs);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
 	udc->fifo = devm_ioremap_resource(&pdev->dev, res);
@@ -2344,6 +2485,7 @@ static int usba_udc_probe(struct platform_device *pdev)
 	udc->pdev = pdev;
 	udc->pclk = pclk;
 	udc->hclk = hclk;
+	udc->id_pin = -ENODEV;
 
 	platform_set_drvdata(pdev, udc);
 
@@ -2354,6 +2496,7 @@ static int usba_udc_probe(struct platform_device *pdev)
 		return ret;
 	}
 
+	dev_dbg(&pdev->dev, "Switch to host by default\n");
 	usba_writel(udc, CTRL, USBA_DISABLE_MASK);
 	clk_disable_unprepare(pclk);
 
@@ -2362,16 +2505,17 @@ static int usba_udc_probe(struct platform_device *pdev)
 	phy_init(udc->phy);
 	phy_set_mode(udc->phy, PHY_MODE_USB_DEVICE);
 
+	dev_dbg(&pdev->dev, "Disable bias\n");
 	toggle_bias(udc, 0);
 
 	if (IS_ERR(udc->usba_ep))
 		return PTR_ERR(udc->usba_ep);
 
 	ret = devm_request_irq(&pdev->dev, irq, usba_udc_irq, 0,
-				"atmel_usba_udc", udc);
+			       "atmel_usba_udc", udc);
 	if (ret) {
-		dev_err(&pdev->dev, "Cannot request irq %d (error %d)\n",
-			irq, ret);
+		dev_err(&pdev->dev, "Cannot request irq %d (error %d)\n", irq,
+			ret);
 		return ret;
 	}
 	udc->irq = irq;
@@ -2379,14 +2523,14 @@ static int usba_udc_probe(struct platform_device *pdev)
 	if (udc->vbus_pin) {
 		irq_set_status_flags(gpiod_to_irq(udc->vbus_pin), IRQ_NOAUTOEN);
 		ret = devm_request_threaded_irq(&pdev->dev,
-				gpiod_to_irq(udc->vbus_pin), NULL,
-				usba_vbus_irq_thread, USBA_VBUS_IRQFLAGS,
-				"atmel_usba_udc", udc);
+						gpiod_to_irq(udc->vbus_pin),
+						NULL, usba_vbus_irq_thread,
+						USBA_VBUS_IRQFLAGS,
+						"atmel_usba_udc", udc);
 		if (ret) {
 			udc->vbus_pin = NULL;
-			dev_warn(&udc->pdev->dev,
-				 "failed to request vbus irq; "
-				 "assuming always on\n");
+			dev_warn(&udc->pdev->dev, "failed to request vbus irq; "
+						  "assuming always on\n");
 		}
 	}
 
@@ -2424,6 +2568,8 @@ static int usba_udc_suspend(struct device *dev)
 {
 	struct usba_udc *udc = dev_get_drvdata(dev);
 
+	dev_dbg(&udc->pdev->dev, "Power suspend\n");
+
 	/* Not started */
 	if (!udc->driver)
 		return 0;
@@ -2457,6 +2603,8 @@ static int usba_udc_resume(struct device *dev)
 {
 	struct usba_udc *udc = dev_get_drvdata(dev);
 
+	dev_dbg(&udc->pdev->dev, "Power resume\n");
+
 	/* Not started */
 	if (!udc->driver)
 		return 0;
diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.h b/drivers/usb/gadget/udc/atmel_usba_udc.h
index 3803bf8af9c3..37771b16b4f3 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.h
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.h
@@ -337,6 +337,7 @@ struct usba_udc {
 	const struct usba_udc_errata *errata;
 	int irq;
 	struct gpio_desc *vbus_pin;
+	int id_pin;
 	int num_ep;
 	struct usba_fifo_cfg *fifo_cfg;
 	struct clk *pclk;
diff --git a/drivers/usb/host/ohci-at91.c b/drivers/usb/host/ohci-at91.c
index e35d516d5050..6edb97ae0334 100644
--- a/drivers/usb/host/ohci-at91.c
+++ b/drivers/usb/host/ohci-at91.c
@@ -12,7 +12,6 @@
  *
  * This file is licenced under the GPL.
  */
-
 #include <linux/clk.h>
 #include <linux/dma-mapping.h>
 #include <linux/gpio/consumer.h>
@@ -50,6 +49,7 @@ static const struct of_device_id at91_ohci_dt_ids[];
 struct at91_usbh_data {
 	struct gpio_desc *vbus_pin[AT91_MAX_USBH_PORTS];
 	struct gpio_desc *overcurrent_pin[AT91_MAX_USBH_PORTS];
+	struct gpio_desc *id_pin[AT91_MAX_USBH_PORTS];
 	u8 ports;				/* number of ports on root hub */
 	u8 overcurrent_supported;
 	u8 overcurrent_status[AT91_MAX_USBH_PORTS];
@@ -401,7 +401,12 @@ static int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
 		case USB_PORT_FEAT_POWER:
 			dev_dbg(hcd->self.controller, "SetPortFeat: POWER\n");
 			if (valid_port(wIndex)) {
-				ohci_at91_usb_set_power(pdata, wIndex, 1);
+				if(!gpiod_get_value(pdata->id_pin[wIndex])){
+					ohci_at91_usb_set_power(pdata, wIndex, 1);
+				}else{
+					dev_dbg(hcd->self.controller,
+						"Passed, device mode\n");
+				}
 				ret = 0;
 			}
 
@@ -559,6 +564,42 @@ static const struct at91_ohci_cfg sama7g5_cfg = {
 	.ohciicr = SAMA7_SFR_OHCIICR,
 };
 
+static irqreturn_t ohci_hcd_at91_otg_id_irq(int irq, void *data)
+{
+	struct platform_device *pdev = data;
+	struct at91_usbh_data *pdata = dev_get_platdata(&pdev->dev);
+	int val, port;
+
+	/* From the GPIO notifying the OTG ID situation, find
+	* out the corresponding port */
+	at91_for_each_port(port) {
+		if (gpiod_to_irq(pdata->id_pin[port]) == irq)
+			break;
+	}
+
+	if (port == AT91_MAX_USBH_PORTS) {
+		dev_err(& pdev->dev, "OTG ID interrupt from unknown GPIO\n");
+		return IRQ_HANDLED;
+	}
+
+	/* debounce */
+	udelay(10);
+
+	val = gpiod_get_value(pdata->id_pin[port]);
+
+	if (val) {
+		dev_dbg(& pdev->dev, "OTG ID gpio changed, new value: device\n");
+		dev_dbg(& pdev->dev, "Disabling output VBUS power\n");
+		ohci_at91_usb_set_power(pdata, port, 0);
+	} else {
+		dev_dbg(& pdev->dev, "OTG ID gpio changed, new value: host\n");
+		dev_dbg(& pdev->dev, "Enabling output VBUS power\n");
+		ohci_at91_usb_set_power(pdata, port, 1);
+	}
+
+	return IRQ_HANDLED;
+}
+
 static const struct of_device_id at91_ohci_dt_ids[] = {
 	{ .compatible = "atmel,at91rm9200-ohci", .data = &at91rm9200_cfg },
 	{ .compatible = "microchip,sama7g5-ohci", .data = &sama7g5_cfg },
@@ -595,13 +636,37 @@ static int ohci_hcd_at91_drv_probe(struct platform_device *pdev)
 	if (!of_property_read_u32(np, "num-ports", &ports))
 		pdata->ports = ports;
 
+	at91_for_each_port(i) {
+		if (i >= pdata->ports)
+			break;
+
+		pdata->id_pin[i] =
+				devm_gpiod_get_index_optional(&pdev->dev, "atmel,id",
+									i, GPIOD_IN);
+		if (!pdata->id_pin[i])
+			continue;
+		if (IS_ERR(pdata->id_pin[i])) {
+			err = PTR_ERR(pdata->id_pin[i]);
+			dev_err(&pdev->dev, "unable to claim gpio \"id\": %d\n", err);
+			continue;
+		}
+
+		ret = devm_request_irq(&pdev->dev,
+								gpiod_to_irq(pdata->id_pin[i]),
+								ohci_hcd_at91_otg_id_irq,
+								IRQF_SHARED,
+								"ohci_otg_id", pdev);
+		if (ret)
+		dev_info(&pdev->dev, "failed to request gpio \"id\" IRQ\n");
+	}
+
 	at91_for_each_port(i) {
 		if (i >= pdata->ports)
 			break;
 
 		pdata->vbus_pin[i] =
 			devm_gpiod_get_index_optional(&pdev->dev, "atmel,vbus",
-						      i, GPIOD_OUT_HIGH);
+						      i, GPIOD_OUT_LOW);
 		if (IS_ERR(pdata->vbus_pin[i])) {
 			err = PTR_ERR(pdata->vbus_pin[i]);
 			dev_err(&pdev->dev, "unable to claim gpio \"vbus\": %d\n", err);
diff --git a/include/linux/mfd/pmic-lorix.h b/include/linux/mfd/pmic-lorix.h
new file mode 100644
index 000000000000..eeb119da0036
--- /dev/null
+++ b/include/linux/mfd/pmic-lorix.h
@@ -0,0 +1,71 @@
+/*
+ * Driver to communicate with the LORIX One PMIC/Reset controller
+ *
+ *  Copyright (C) 2016 Wifx,
+ *                2016 Yannick Lanz <yannick.lanz@wifx.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef __LINUX_PMIC_LORIX_ONE_H
+#define __LINUX_PMIC_LORIX_ONE_H
+#include <linux/leds.h>
+
+struct attiny {
+    struct device *dev;
+    struct i2c_client *client;
+
+    struct mutex lock;
+
+    unsigned long id;
+
+    // attiny cached values
+    void *cache;
+    // subdevice
+    struct device *machine_dev;
+};
+
+/*
+ * LEDs subdevice platform data
+ */
+struct attiny_led_platform_data {
+    int id;
+    const char *name;
+    const char *default_trigger;
+};
+
+#define MAX_LED_CONTROL_REGS    1
+
+struct attiny_leds_platform_data {
+    struct attiny_led_platform_data *led;
+    int num_leds;
+    u32 led_control[MAX_LED_CONTROL_REGS];
+};
+
+/*
+ * GPIOs subdevice bits and masks
+ */
+struct lorix_gpio_platform_data {
+    unsigned gpio_start;
+    u8 gpio_en_mask;
+    u8 gpio_pullup_mask;
+};
+
+/*
+ * MFD chip platform data
+ */
+struct attiny_platform_data {
+    unsigned int flags;
+
+    struct attiny_leds_platform_data *leds;
+};
+
+/*
+ * MFD chip functions
+ */
+extern int pmic_lorix_read(struct attiny *attiny, int reg, uint8_t *val);
+extern int pmic_lorix_write(struct attiny *attiny, int reg, uint8_t val);
+
+#endif /* __LINUX_PMIC_LORIX_ONE_H */
-- 
2.34.1

