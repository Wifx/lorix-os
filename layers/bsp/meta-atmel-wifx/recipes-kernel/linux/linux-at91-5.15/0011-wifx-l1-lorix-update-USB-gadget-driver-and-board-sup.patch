From bddb454e4d0f4aab6bf8780cb23e9e4292d28367 Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Wed, 19 Oct 2022 15:09:39 +0200
Subject: [PATCH 2/2] wifx l1/lorix: update USB gadget driver and board support
 to improve state mgmt

Signed-off-by: Yannick Lanz <yannick.lanz@wifx.net>
---
 arch/arm/boot/dts/l1.dts                |  42 +--
 arch/arm/boot/dts/lorix-one-base.dtsi   |  45 ++-
 arch/arm/configs/l1_defconfig           |   7 +-
 arch/arm/configs/lorixone_defconfig     |   6 +-
 drivers/leds/trigger/ledtrig-wgw-usbc.c | 105 ++++---
 drivers/mfd/Kconfig                     |   1 +
 drivers/mfd/wgw_ec_usbc.c               | 255 +++++++++++++----
 drivers/usb/gadget/udc/Kconfig          |   1 +
 drivers/usb/gadget/udc/atmel_usba_udc.c | 351 ++++++++++--------------
 drivers/usb/gadget/udc/atmel_usba_udc.h |  14 +-
 include/linux/mfd/wgw-ec/usbc.h         |  37 ++-
 11 files changed, 503 insertions(+), 361 deletions(-)

diff --git a/arch/arm/boot/dts/l1.dts b/arch/arm/boot/dts/l1.dts
index 03cbfdae4c0c..3c6a0a5f89cb 100644
--- a/arch/arm/boot/dts/l1.dts
+++ b/arch/arm/boot/dts/l1.dts
@@ -151,6 +151,19 @@ usb_typec:usbc {
 						compatible = "wifx,wgw-ec-usbc";
 						#trigger-source-cells = <0>;
 						status = "okay";
+
+						port {
+							typec0_dr_sw: endpoint {
+								remote-endpoint = <&usb0_drd_sw>;
+							};
+						};
+
+						connector {
+							compatible = "usb-c-connector";
+							power-role = "dual";
+							data-role = "dual";
+							status = "okay";
+						};
 					};
 
 					leds {
@@ -298,27 +311,24 @@ pinctrl_gnss_pps: gnss_pps {
 		};
 
 		usb0: gadget@400000 {
-			atmel,vbus-gpio = <&pioE 31 GPIO_ACTIVE_HIGH>;
-			atmel,id-gpio = <&pioD 11 GPIO_ACTIVE_HIGH>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&pinctrl_usb_vbus>;
+			dr_mode = "otg";
+			hnp-disable;
+			srp-disable;
+			adp-disable;
+			usb-role-switch;
 			status = "okay";
+
+			port {
+				usb0_drd_sw: endpoint {
+					remote-endpoint = <&typec0_dr_sw>;
+				};
+			};
 		};
 
 		usb1: ohci@500000 {
 			num-ports = <3>;
-			atmel,vbus-gpio = <
-				0
-				0
-				0
-			>;
-			atmel,id-gpio = <
-				&pioD 11 GPIO_ACTIVE_HIGH
-				0
-				0
-			>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&pinctrl_usb_id>;
+			atmel,vbus-gpio = <0 0 0>;
+			atmel,id-gpio = <0 0 0>;
 			status = "okay";
 		};
 
diff --git a/arch/arm/boot/dts/lorix-one-base.dtsi b/arch/arm/boot/dts/lorix-one-base.dtsi
index 35f38dddc56c..ce2cfbaaf1d2 100644
--- a/arch/arm/boot/dts/lorix-one-base.dtsi
+++ b/arch/arm/boot/dts/lorix-one-base.dtsi
@@ -211,25 +211,32 @@ pinctrl_sx1301_scanmode: sx1301_scanmode {
 		};
 
 		usb0: gadget@400000 {
-			atmel,vbus-gpio = <&pioE 31 GPIO_ACTIVE_HIGH>;
-			atmel,id-gpio = <&pioD 11 GPIO_ACTIVE_HIGH>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&pinctrl_usba_vbus>;
+			dr_mode = "otg";
+			hnp-disable;
+			srp-disable;
+			adp-disable;
+			usb-role-switch;
 			status = "okay";
+
+			connector {
+				compatible = "gpio-usb-b-connector", "usb-b-connector";
+				label = "USB mini-AB";
+				type = "mini";
+				status = "okay";
+
+				id-gpios = <&pioD 11 GPIO_ACTIVE_HIGH>;
+				vbus-gpios = <&pioE 31 GPIO_ACTIVE_HIGH>;
+				vbus-supply = <&vbus_usb_reg>;
+
+				pinctrl-names = "default";
+				pinctrl-0 = <&pinctrl_usba_vbus &pinctrl_usb_id>;
+			};
 		};
 
 		usb1: ohci@500000 {
 			num-ports = <3>;
-			atmel,vbus-gpio = <&pioD 12 GPIO_ACTIVE_HIGH
-				0
-				0
-			>;
-			atmel,id-gpio = <&pioD 11 GPIO_ACTIVE_HIGH
-				0
-				0
-			>;
-			pinctrl-names = "default";
-			pinctrl-0 = <&pinctrl_usb_id>;
+			atmel,vbus-gpio = <0 0 0>;
+			atmel,id-gpio = <0 0 0>;
 			status = "okay";
 		};
 
@@ -296,4 +303,14 @@ vddbu_2v_reg: fixedregulator@0 {
 		regulator-boot-on;
 		regulator-always-on;
 	};
+
+	vbus_usb_reg: fixedregulator_vbus_usb {
+		compatible = "regulator-fixed";
+		regulator-name = "VBUS USB";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-boot-on;
+		enable-active-high;
+		gpio = <&pioD 12 GPIO_ACTIVE_HIGH>;
+	};
 };
diff --git a/arch/arm/configs/l1_defconfig b/arch/arm/configs/l1_defconfig
index 2f144130cd63..01b62544c8a0 100644
--- a/arch/arm/configs/l1_defconfig
+++ b/arch/arm/configs/l1_defconfig
@@ -35,7 +35,6 @@ CONFIG_MODULES=y
 CONFIG_MODULE_FORCE_LOAD=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
 CONFIG_CMA=y
 CONFIG_CMA_DEBUGFS=y
@@ -114,7 +113,6 @@ CONFIG_PINCTRL_AT91PIO4=y
 CONFIG_GPIO_SYSFS=y
 CONFIG_GPIO_SYSCON=y
 CONFIG_POWER_RESET=y
-CONFIG_POWER_SUPPLY=y
 CONFIG_BATTERY_ACT8945A=y
 CONFIG_SENSORS_STTS751=y
 CONFIG_THERMAL=y
@@ -135,6 +133,7 @@ CONFIG_REGULATOR_ACT8865=y
 CONFIG_REGULATOR_ACT8945A=y
 # CONFIG_HID is not set
 # CONFIG_USB_HID is not set
+CONFIG_USB_CONN_GPIO=y
 CONFIG_USB=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 CONFIG_USB_EHCI_HCD=y
@@ -147,6 +146,8 @@ CONFIG_USB_GADGET=y
 CONFIG_USB_ATMEL_USBA=y
 CONFIG_USB_CONFIGFS=m
 CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
 CONFIG_USB_G_SERIAL=m
 CONFIG_TYPEC=y
 CONFIG_MMC=y
@@ -203,7 +204,6 @@ CONFIG_CRYPTO_CBC=y
 CONFIG_CRYPTO_XTS=y
 CONFIG_CRYPTO_MD5=y
 CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_SM3=y
 CONFIG_CRYPTO_ARC4=y
 CONFIG_CRYPTO_DES=y
@@ -213,7 +213,6 @@ CONFIG_CRYPTO_USER_API_SKCIPHER=m
 CONFIG_CRYPTO_DEV_ATMEL_AES=y
 CONFIG_CRYPTO_DEV_ATMEL_TDES=y
 CONFIG_CRYPTO_DEV_ATMEL_SHA=y
-CONFIG_CRYPTO_DEV_ATMEL_ECC=m
 CONFIG_CRC_CCITT=m
 CONFIG_CRC_ITU_T=m
 CONFIG_STRIP_ASM_SYMS=y
diff --git a/arch/arm/configs/lorixone_defconfig b/arch/arm/configs/lorixone_defconfig
index ebe253b7261b..b3d0533396f7 100644
--- a/arch/arm/configs/lorixone_defconfig
+++ b/arch/arm/configs/lorixone_defconfig
@@ -35,7 +35,6 @@ CONFIG_MODULES=y
 CONFIG_MODULE_FORCE_LOAD=y
 CONFIG_MODULE_UNLOAD=y
 CONFIG_MODULE_FORCE_UNLOAD=y
-# CONFIG_BLK_DEV_BSG is not set
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
 CONFIG_CMA=y
 CONFIG_CMA_DEBUGFS=y
@@ -114,7 +113,6 @@ CONFIG_PINCTRL_AT91PIO4=y
 CONFIG_GPIO_SYSFS=y
 CONFIG_GPIO_SYSCON=y
 CONFIG_POWER_RESET=y
-CONFIG_POWER_SUPPLY=y
 CONFIG_BATTERY_ACT8945A=y
 CONFIG_SENSORS_LM75=y
 CONFIG_THERMAL=y
@@ -132,6 +130,7 @@ CONFIG_REGULATOR_ACT8865=y
 CONFIG_REGULATOR_ACT8945A=y
 # CONFIG_HID is not set
 # CONFIG_USB_HID is not set
+CONFIG_USB_CONN_GPIO=y
 CONFIG_USB=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
 CONFIG_USB_EHCI_HCD=y
@@ -144,6 +143,8 @@ CONFIG_USB_GADGET=y
 CONFIG_USB_ATMEL_USBA=y
 CONFIG_USB_CONFIGFS=m
 CONFIG_USB_CONFIGFS_ACM=y
+CONFIG_USB_CONFIGFS_RNDIS=y
+CONFIG_USB_CONFIGFS_MASS_STORAGE=y
 CONFIG_USB_G_SERIAL=m
 CONFIG_MMC=y
 CONFIG_MMC_SDHCI=y
@@ -197,7 +198,6 @@ CONFIG_CRYPTO_CBC=y
 CONFIG_CRYPTO_XTS=y
 CONFIG_CRYPTO_MD5=y
 CONFIG_CRYPTO_SHA1=y
-CONFIG_CRYPTO_SHA512=y
 CONFIG_CRYPTO_SM3=y
 CONFIG_CRYPTO_ARC4=y
 CONFIG_CRYPTO_DES=y
diff --git a/drivers/leds/trigger/ledtrig-wgw-usbc.c b/drivers/leds/trigger/ledtrig-wgw-usbc.c
index d16ed0a93803..72685403c54e 100644
--- a/drivers/leds/trigger/ledtrig-wgw-usbc.c
+++ b/drivers/leds/trigger/ledtrig-wgw-usbc.c
@@ -29,8 +29,8 @@ struct wgw_usbc_trig_data {
 	spinlock_t lock;
 
 	struct led_classdev *led_cdev;
-	struct device *usbc_dev;
-	struct wgw_ec_usbc_dev *usbc;
+	/* trigger object platform device */
+	struct platform_device *trig_pdev;
 
 	struct delayed_work work;
 	struct notifier_block notifier;
@@ -89,24 +89,33 @@ ATTRIBUTE_GROUPS(wgw_usbc_trig);
 static int wgw_usbc_trig_notify(struct notifier_block *notifier,
 				unsigned long evt, void *dv)
 {
+	struct wgw_ec_usbc_notification *notif =
+		(struct wgw_ec_usbc_notification *)dv;
 	struct wgw_usbc_trig_data *trigger_data =
 		container_of(notifier, struct wgw_usbc_trig_data, notifier);
 
-	pr_debug("wgw-usbc-trig notify notified by wgw-ec-usbc\n");
+	struct device *dev = trigger_data->led_cdev->dev;
 
-	if (evt == WGW_USBC_DATA_MODE_CHANGE) {
-		enum usb_data_mode data_mode =
-			wgw_ec_usbc_get_data_mode(trigger_data->usbc);
+	dev_dbg(dev, "wgw-usbc-trig notify notified by wgw-ec-usbc\n");
 
+	if (notif->dev != &trigger_data->trig_pdev->dev)
+	{
+		dev_dbg(dev, "LED trigger not concerned by the wgw-ec-usbc event\n");
+		return NOTIFY_DONE;
+	}
+
+	if (evt == WGW_USBC_DATA_MODE_CHANGE ||
+	    evt == WGW_USBC_DEVICE_PROBE ||
+	    evt == WGW_USBC_NOTIFIER_UPDATE) {
 		cancel_delayed_work_sync(&trigger_data->work);
 
 		pr_debug(
 			"trigger notified for data mode change, new value=%d\n",
-			data_mode);
+			notif->data_mode);
 
 		spin_lock_bh(&trigger_data->lock);
 		trigger_data->led_on =
-			(data_mode == USB_DATA_MODE_DEVICE ? 1 : 0);
+			(notif->data_mode == USB_DATA_MODE_DEVICE ? 1 : 0);
 		schedule_delayed_work(&trigger_data->work, 0);
 		spin_unlock_bh(&trigger_data->lock);
 
@@ -135,25 +144,27 @@ static int wgw_usbc_trig_activate(struct led_classdev *led_cdev)
 {
 	// retrieve the attached LED
 	struct device *dev = led_cdev->dev;
-	struct platform_device *pdev_trigger;
 	struct device_node *of_node;
 	struct of_phandle_args of_trigger_handle;
 	struct wgw_usbc_trig_data *trigger_data;
-	enum usb_data_mode data_mode;
-	int count, err, ret;
+	int ret = -ENODEV, count;
 
 	dev_dbg(dev, "wgw-usbc-trig activate\n");
 
 	if (!dev) {
 		pr_err("wgw-usbc-data-mode: no LED device attached\n");
-		return -ENODEV;
+		return ret;
 	}
 	dev_dbg(dev, "registering trigger for led %s\n", led_cdev->name);
 
+	trigger_data = kzalloc(sizeof(struct wgw_usbc_trig_data), GFP_KERNEL);
+	if (!trigger_data)
+		return -ENOMEM;
+
 	/* Retrieve the of node */
 	if (!dev->fwnode) {
 		dev_err(dev, "wgw-usbc-data-mode: no LED dev fwnode\n");
-		return -ENODEV;
+		return ret;
 	}
 	of_node = to_of_node(dev->fwnode);
 
@@ -162,28 +173,28 @@ static int wgw_usbc_trig_activate(struct led_classdev *led_cdev)
 					   "#trigger-source-cells");
 	if (count == -ENOENT) {
 		dev_err(dev, "wgw-usbc-data-mode: no trigger phandle found\n");
-		goto put_of_node;
+		return ret;
 	} else if (count < 0) {
 		dev_err(dev,
 			"wgw-usbc-data-mode: Failed to get trigger sources for %pOF\n",
 			of_node);
-		goto put_of_node;
+		return ret;
 	} else if (count != 1) {
 		dev_err(dev,
 			"wgw-usbc-data-mode: Too much trigger sources (%d), max is 1\n",
 			count);
-		goto put_of_node;
+		return ret;
 	}
 
 	/* Retrieve the trigger source phandle */
-	err = of_parse_phandle_with_args(of_node, "trigger-sources",
+	ret = of_parse_phandle_with_args(of_node, "trigger-sources",
 					 "#trigger-source-cells", 0,
 					 &of_trigger_handle);
-	if (err) {
+	if (ret) {
 		dev_err(dev,
 			"wgw-usbc-data-mode: Failed to get trigger source phandle: %d\n",
-			err);
-		goto put_of_node;
+			ret);
+		return ret;
 	}
 	/* Only supported trigger source is wgw-ec-usbc */
 	if (!of_device_is_compatible(of_trigger_handle.np,
@@ -193,56 +204,39 @@ static int wgw_usbc_trig_activate(struct led_classdev *led_cdev)
 			of_trigger_handle.np->name);
 		goto put_trigger_handle;
 	}
-	pdev_trigger = of_find_device_by_node(of_trigger_handle.np);
-	if (IS_ERR_OR_NULL(pdev_trigger)) {
+	trigger_data->trig_pdev = of_find_device_by_node(of_trigger_handle.np);
+	if (IS_ERR_OR_NULL(trigger_data->trig_pdev)) {
 		dev_err(dev,
 			"wgw-usbc-data-mode: platform device from of_device not found\n");
 		goto put_trigger_handle;
 	}
-	of_node_put(of_trigger_handle.np);
-	of_node_put(of_node);
-
-	trigger_data = kzalloc(sizeof(struct wgw_usbc_trig_data), GFP_KERNEL);
-	if (!trigger_data) {
-		goto put_device;
-	}
 
-	/* we know this plaftorm device contains a wgw_ec_usbc_dev */
-	trigger_data->usbc_dev = &pdev_trigger->dev;
-	trigger_data->usbc = (struct wgw_ec_usbc_dev *)dev_get_drvdata(
-		trigger_data->usbc_dev);
+	trigger_data->led_cdev = led_cdev;
+	trigger_data->led_on = 0;
+	trigger_data->enabled = 0;
 
 	spin_lock_init(&trigger_data->lock);
-	trigger_data->notifier.notifier_call = wgw_usbc_trig_notify;
-	trigger_data->notifier.priority = 10;
 	INIT_DELAYED_WORK(&trigger_data->work, wgw_usbc_trig_work);
 
-	trigger_data->led_cdev = led_cdev;
 	led_set_trigger_data(led_cdev, trigger_data);
 
-	ret = blocking_notifier_chain_register(
-		&trigger_data->usbc->notifier_list, &trigger_data->notifier);
-	if (ret) {
-		kfree(trigger_data);
+	trigger_data->notifier.notifier_call = wgw_usbc_trig_notify;
+	trigger_data->notifier.priority = 10;
+	// prepare notifier
+	ret = wgw_ec_usbc_register_notifier(&trigger_data->notifier);
+	if (ret < 0) {
+		dev_err(dev, "error registering usbc notifier: %d\n", ret);
 		goto put_device;
 	}
 
-	/* Init LED state */
-	data_mode = wgw_ec_usbc_get_data_mode(trigger_data->usbc);
-	spin_lock_bh(&trigger_data->lock);
-	trigger_data->led_on = (data_mode == USB_DATA_MODE_DEVICE ? 1 : 0);
-	schedule_delayed_work(&trigger_data->work, 0);
-	spin_unlock_bh(&trigger_data->lock);
-
-	return ret;
+	of_node_put(of_trigger_handle.np);
+	return 0;
 
 put_device:
-	put_device(&pdev_trigger->dev);
+	put_device(&trigger_data->trig_pdev->dev);
 put_trigger_handle:
 	of_node_put(of_trigger_handle.np);
-put_of_node:
-	of_node_put(of_node);
-	return -ENODEV;
+	return ret;
 }
 
 static void wgw_usbc_trig_deactivate(struct led_classdev *led_cdev)
@@ -252,13 +246,12 @@ static void wgw_usbc_trig_deactivate(struct led_classdev *led_cdev)
 
 	pr_debug("wgw-usbc-trig deactivate\n");
 
-	blocking_notifier_chain_unregister(&trigger_data->usbc->notifier_list,
-					   &trigger_data->notifier);
+	wgw_ec_usbc_unregister_notifier(&trigger_data->notifier);
 
 	cancel_delayed_work_sync(&trigger_data->work);
 
-	if (trigger_data->usbc_dev)
-		put_device(trigger_data->usbc_dev);
+	if (trigger_data->trig_pdev)
+		put_device(&trigger_data->trig_pdev->dev);
 
 	kfree(trigger_data);
 }
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index f09c7b091d2d..c4ed9b7aee09 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -144,6 +144,7 @@ config MFD_WGW_EC_I2C
 config MFD_WGW_EC_USBC
 	tristate "USB Type-C management through Wifx board EC"
 	depends on MFD_WGW_EC_DEV && TYPEC
+	select USB_ROLE_SWITCH
 	help
 	  This option enables support for the on-chip USB Type-C driver managed
 	  by the Embedded Controller on Wifx board.
diff --git a/drivers/mfd/wgw_ec_usbc.c b/drivers/mfd/wgw_ec_usbc.c
index 57b32338f634..74840d3f9263 100644
--- a/drivers/mfd/wgw_ec_usbc.c
+++ b/drivers/mfd/wgw_ec_usbc.c
@@ -17,6 +17,8 @@
 #include <linux/err.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
 
 #include <linux/mfd/wgw-ec/core.h>
 #include <linux/mfd/wgw-ec/reg.h>
@@ -24,6 +26,17 @@
 
 #define DRV_NAME "wgw-ec-usbc"
 
+#define REG_INTERRUPT_DATA_MODE_CHANGE	0x01
+#define REG_INTERRUPT_POWER_MODE_CHANGE	0x02
+
+struct wgw_ec_driver_data {
+	struct mutex lock;
+	struct blocking_notifier_head notifier_list;	// event listener list
+	struct list_head device_list;			// device list
+};
+
+static struct wgw_ec_driver_data *drv_data;
+
 static const struct of_device_id wgw_ec_usbc_of_match[] = {
 	{
 		.compatible = "wifx,wgw-ec-usbc",
@@ -152,28 +165,39 @@ static int wgw_ec_usbc_dr_set(struct typec_port *port,
 	struct wgw_ec_usbc_dev *usbc = typec_get_drvdata(port);
 	ssize_t status;
 
-	pr_debug("wgw_ec_usbc_dr_set: %d\n", role);
+	dev_dbg(usbc->dev, "wgw_ec_usbc_dr_set: %d\n", role);
 	status = data_mode_set(usbc, (enum usb_data_mode)role);
-	if (status < 0) {
+	if (status < 0)
 		return status;
-	}
 
 	typec_set_data_role(usbc->port, role);
 	return 0;
 }
 
+static enum usb_role wgw_ec_usbc_data_mode_to_role(enum usb_data_mode data_mode)
+{
+	switch(data_mode) {
+	case USB_DATA_MODE_DEVICE:
+		return USB_ROLE_DEVICE;
+	case USB_DATA_MODE_HOST:
+		return USB_ROLE_HOST;
+	case USB_DATA_MODE_ERROR:
+	default:
+		return USB_ROLE_NONE;
+	}
+}
+
 static int wgw_ec_usbc_trig_notify(struct notifier_block *nb, unsigned long evt,
 				   void *dv)
 {
 	struct wgw_ec_usbc_dev *usbc =
 		container_of(nb, struct wgw_ec_usbc_dev, notifier);
 	struct wgw_ec_device *ec_dev = usbc->ec->ec_dev;
-	enum usb_data_mode usb_data_mode;
-	enum usb_power_mode usb_power_mode;
+	struct wgw_ec_usbc_notification notif;
 	int ret;
 	u8 reg;
 
-	pr_debug("wgw-ec-usbc notified by wgw-ec-core\n");
+	dev_dbg(usbc->dev, "notified by wgw-ec-core\n");
 
 	ret = ec_dev->read_byte(ec_dev, WGW_EC_REG_INTERRUPT, &reg);
 	if (ret < 0) {
@@ -181,53 +205,68 @@ static int wgw_ec_usbc_trig_notify(struct notifier_block *nb, unsigned long evt,
 		return NOTIFY_DONE;
 	}
 
-	if (reg & WGW_USBC_DATA_MODE_CHANGE) {
-		ret = data_mode_get(usbc, &usb_data_mode);
-		if (ret < 0) {
-			dev_err(usbc->dev,
-				"failed to read USB-C data mode register\n");
-			goto failure;
-		}
+	// init notification object
+	notif.dev = usbc->dev;
+	ret = data_mode_get(usbc, &notif.data_mode);
+	if (ret < 0) {
+		dev_err(usbc->dev,
+			"failed to read USB-C data mode register\n");
+		goto failure;
+	}
+	ret = power_mode_get(usbc, &notif.power_mode);
+	if (ret < 0) {
+		dev_err(usbc->dev,
+			"failed to read USB-C power mode register\n");
+		goto failure;
+	}
+
+	if (reg & REG_INTERRUPT_DATA_MODE_CHANGE) {
 		spin_lock_bh(&usbc->lock);
-		if (usbc->data_mode != usb_data_mode) {
-			usbc->data_mode = usb_data_mode;
+		if (usbc->data_mode != notif.data_mode) {
+			usbc->data_mode = notif.data_mode;
 			spin_unlock_bh(&usbc->lock);
+			typec_set_data_role(usbc->port, notif.data_mode);
+
+			if (notif.power_mode != USB_POWER_MODE_DETACHED) {
+				ret = usb_role_switch_set_role(usbc->role_sw,
+					wgw_ec_usbc_data_mode_to_role(notif.data_mode));
+				if (ret)
+					dev_err(usbc->dev, "failed to set role: %d\n", ret);
+			}
 
-			typec_set_data_role(usbc->port, usb_data_mode);
-			blocking_notifier_call_chain(&usbc->notifier_list,
+			blocking_notifier_call_chain(&drv_data->notifier_list,
 						     WGW_USBC_DATA_MODE_CHANGE,
-						     NULL);
+						     &notif);
 		} else {
 			spin_unlock_bh(&usbc->lock);
 		}
 	}
 
-	if (reg & WGW_USBC_POWER_MODE_CHANGE) {
-		ret = power_mode_get(usbc, &usb_power_mode);
-		if (ret < 0) {
-			dev_err(usbc->dev,
-				"failed to read USB-C power mode register\n");
-			goto failure;
-		}
+	if (reg & REG_INTERRUPT_POWER_MODE_CHANGE) {
 		spin_lock_bh(&usbc->lock);
-		if (usbc->power_mode != usb_power_mode) {
+		if (usbc->power_mode != notif.power_mode) {
 			spin_unlock_bh(&usbc->lock);
-			if (usbc->power_mode == USB_POWER_MODE_DETACHED) {
+			if (notif.power_mode == USB_POWER_MODE_DETACHED) {
+				dev_dbg(usbc->dev, "USB-C detach event\n");
+				wgw_ec_usbc_disconnect(usbc, notif.power_mode);
+				ret = usb_role_switch_set_role(usbc->role_sw, USB_ROLE_NONE);
+				if (ret)
+					dev_err(usbc->dev, "failed to set role: %d\n", ret);
+			} else if (notif.power_mode != USB_POWER_MODE_ERROR) {
 				pr_debug("USB-C attach event\n");
-
-				ret = wgw_ec_usbc_connect(usbc, usb_power_mode);
+				ret = wgw_ec_usbc_connect(usbc, notif.power_mode);
 				if (ret)
 					dev_err(usbc->dev,
 						"failed to register partner\n");
-			}
-			if (usb_power_mode == USB_POWER_MODE_DETACHED) {
-				pr_debug("USB-C detach event\n");
-				wgw_ec_usbc_disconnect(usbc, usb_power_mode);
+				ret = usb_role_switch_set_role(usbc->role_sw, 
+					wgw_ec_usbc_data_mode_to_role(notif.data_mode));
+				if (ret)
+					dev_err(usbc->dev, "failed to set role: %d\n", ret);
 			}
 
-			blocking_notifier_call_chain(&usbc->notifier_list,
+			blocking_notifier_call_chain(&drv_data->notifier_list,
 						     WGW_USBC_POWER_MODE_CHANGE,
-						     NULL);
+						     &notif);
 		} else {
 			spin_unlock_bh(&usbc->lock);
 		}
@@ -279,26 +318,46 @@ static int wgw_ec_usbc_probe(struct platform_device *pdev)
 	struct device *dev = &pdev->dev;
 	struct device_node *of_parent = ec->ec_dev->dev->of_node;
 	struct wgw_ec_usbc_dev *usbc;
-	int ret;
+	struct wgw_ec_usbc_notification notif;
+	int ret = -ENODEV;
 
-	usbc = devm_kzalloc(dev, sizeof(struct wgw_ec_usbc_dev), GFP_KERNEL);
+	usbc = devm_kzalloc(dev, sizeof(*usbc), GFP_KERNEL);
 	if (!usbc)
 		return -ENOMEM;
 
 	usbc->ec = ec;
 	usbc->dev = dev;
-	platform_set_drvdata(pdev, usbc);
 
 	dev->of_node = of_get_compatible_child(
 		of_parent, wgw_ec_usbc_of_match->compatible);
 	if (!dev->of_node) {
 		dev_err(dev, "no compatible usb node in dt\n");
+		return ret;
+	}
+
+	usbc->role_sw = usb_role_switch_get(dev);
+	if (IS_ERR(usbc->role_sw)) {
+		if (PTR_ERR(usbc->role_sw) != -EPROBE_DEFER) {
+			dev_err(dev, "failed to get role switch\n");
+		}
+		dev_info(dev, "Defer probing for USB role switch acquisition\n");
+		ret = PTR_ERR(usbc->role_sw);
 		goto put_node;
 	}
 
-	/* Retrieve USB-C power and data mode */
-	power_mode_get(usbc, &usbc->power_mode);
-	data_mode_get(usbc, &usbc->data_mode);
+	// we try to retrieve data and power mode
+	ret = data_mode_get(usbc, &usbc->data_mode);
+	if (ret < 0) {
+		dev_err(dev,
+			"failed to read USB-C data mode register\n");
+		goto put_role_sw;
+	}
+	ret = power_mode_get(usbc, &usbc->power_mode);
+	if (ret < 0) {
+		dev_err(dev,
+			"failed to read USB-C power mode register\n");
+		goto put_role_sw;
+	}
 
 	dev_info(dev,
 		 "USB-C controller detected: power mode=%s, data mode=%s\n",
@@ -306,14 +365,13 @@ static int wgw_ec_usbc_probe(struct platform_device *pdev)
 		 data_mode_to_str(usbc->data_mode));
 
 	spin_lock_init(&usbc->lock);
-	BLOCKING_INIT_NOTIFIER_HEAD(&usbc->notifier_list);
 	usbc->notifier.priority = 10;
 	usbc->notifier.notifier_call = wgw_ec_usbc_trig_notify;
 	ret = blocking_notifier_chain_register(&ec->ec_dev->notifier_list,
 					       &usbc->notifier);
 	if (ret < 0) {
 		dev_err(dev, "failed to register to wgw-ec notifier list\n");
-		goto put_node;
+		goto put_role_sw;
 	}
 
 	usbc->typec_cap.revision = USB_TYPEC_REV_1_1;
@@ -325,13 +383,37 @@ static int wgw_ec_usbc_probe(struct platform_device *pdev)
 	usbc->port = typec_register_port(dev, &usbc->typec_cap);
 	if (IS_ERR(usbc->port)) {
 		ret = PTR_ERR(usbc->port);
-		goto put_node;
+		goto put_role_sw;
 	}
 
 	typec_set_data_role(usbc->port, usbc->data_mode);
+	if (usbc->power_mode == USB_POWER_MODE_DETACHED)
+		ret = usb_role_switch_set_role(usbc->role_sw, USB_ROLE_NONE);
+	else
+		ret = usb_role_switch_set_role(usbc->role_sw, 
+			wgw_ec_usbc_data_mode_to_role(usbc->data_mode));
+	if (ret)
+		dev_err(usbc->dev, "failed to set role: %d\n", ret);
 	wgw_ec_usbc_connect(usbc, usbc->power_mode);
+
+	platform_set_drvdata(pdev, usbc);
+
+	mutex_lock(&drv_data->lock);
+	list_add_tail(&usbc->list_node, &drv_data->device_list);
+	mutex_unlock(&drv_data->lock);
+
+	notif.dev = usbc->dev;
+	notif.data_mode = usbc->data_mode;
+	notif.power_mode = usbc->power_mode;
+	blocking_notifier_call_chain(&drv_data->notifier_list,
+				     WGW_USBC_DEVICE_PROBE,
+				     &notif);
+
 	return 0;
 
+put_role_sw:
+	usb_role_switch_put(usbc->role_sw);
+
 put_node:
 	of_node_put(dev->of_node);
 	return ret;
@@ -340,11 +422,16 @@ static int wgw_ec_usbc_probe(struct platform_device *pdev)
 static int wgw_ec_usbc_remove(struct platform_device *pdev)
 {
 	struct wgw_ec_usbc_dev *usbc = platform_get_drvdata(pdev);
-	pr_debug("wgw-ec-usbc remove\n");
+
+	mutex_lock(&drv_data->lock);
+	list_del(&usbc->list_node);
 	blocking_notifier_chain_unregister(&usbc->ec->ec_dev->notifier_list,
 					   &usbc->notifier);
+	mutex_unlock(&drv_data->lock);
+
 	wgw_ec_usbc_disconnect(usbc, USB_POWER_MODE_DETACHED);
 	typec_unregister_port(usbc->port);
+	usb_role_switch_put(usbc->role_sw);
 	of_node_put(pdev->dev.of_node);
 	return 0;
 }
@@ -357,7 +444,83 @@ static struct platform_driver wgw_ec_usbc_driver = {
 	.probe = wgw_ec_usbc_probe,
 	.remove = wgw_ec_usbc_remove,
 };
-module_platform_driver(wgw_ec_usbc_driver);
+
+int wgw_ec_usbc_register_notifier(struct notifier_block *nb)
+{
+	int ret = 0;
+	struct wgw_ec_usbc_dev *usbc;
+	struct wgw_ec_usbc_notification notif;
+
+	pr_debug("wgw_ec_usbc register a new notifier\n");
+
+	ret = blocking_notifier_chain_register(&drv_data->notifier_list, nb);
+	if (ret < 0) {
+		pr_err("wgw_ec_usbc: failed to register a new notifier: %d\n", ret);
+		return ret;
+	}
+
+	mutex_lock(&drv_data->lock);
+	list_for_each_entry(usbc, &drv_data->device_list, list_node) {
+		notif.dev = usbc->dev;
+		notif.data_mode = usbc->data_mode;
+		notif.power_mode = usbc->power_mode;
+
+		blocking_notifier_call_chain(&drv_data->notifier_list,
+				     WGW_USBC_NOTIFIER_UPDATE,
+				     &notif);
+	}
+	mutex_unlock(&drv_data->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wgw_ec_usbc_register_notifier);
+
+int wgw_ec_usbc_unregister_notifier(struct notifier_block *nb)
+{
+	int ret = 0;
+
+	pr_debug("wgw_ec_usbc unregister a notifier\n");
+	ret = blocking_notifier_chain_unregister(&drv_data->notifier_list, nb);
+	if (ret < 0) {
+		pr_err("wgw_ec_usbc: failed to unregister a notifier: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(wgw_ec_usbc_unregister_notifier);
+
+static int __init wgw_ec_usbc_init(void)
+{
+	int ret = 0;
+
+	pr_devel("wgw_ec_usbc init\n");
+
+	drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);
+	if (!drv_data)
+		return -ENOMEM;
+
+	mutex_init(&drv_data->lock);
+	BLOCKING_INIT_NOTIFIER_HEAD(&drv_data->notifier_list);
+	INIT_LIST_HEAD(&drv_data->device_list);
+
+	/* Register the driver */
+	ret = platform_driver_register(&wgw_ec_usbc_driver);
+	if (ret < 0)
+		pr_warn("wgw_ec_usbc: can't register driver: %d\n", ret);
+
+	return ret;
+}
+
+static void __exit wgw_ec_usbc_exit(void)
+{
+	pr_devel("wgw_ec_usbc exit\n");
+	platform_driver_unregister(&wgw_ec_usbc_driver);
+	kfree(drv_data);
+}
+
+module_init(wgw_ec_usbc_init);
+module_exit(wgw_ec_usbc_exit);
 
 MODULE_ALIAS("platform:" DRV_NAME);
 MODULE_AUTHOR("Yannick Lanz <yannick.lanz@wifx.net>");
diff --git a/drivers/usb/gadget/udc/Kconfig b/drivers/usb/gadget/udc/Kconfig
index 69394dc1cdfb..6f1f04eb35ae 100644
--- a/drivers/usb/gadget/udc/Kconfig
+++ b/drivers/usb/gadget/udc/Kconfig
@@ -58,6 +58,7 @@ config USB_LPC32XX
 config USB_ATMEL_USBA
 	tristate "Atmel USBA"
 	depends on ARCH_AT91
+	select USB_ROLE_SWITCH
 	help
 	  USBA is the integrated high-speed USB Device controller on
 	  the AT32AP700x, some AT91SAM9 and AT91CAP9 processors from Atmel.
diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c
index 6fb2596eae6c..6f0f56e824a6 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.c
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_gpio.h>
+#include <linux/of_platform.h>
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/slab.h>
@@ -480,24 +481,6 @@ static inline void usba_int_enb_clear(struct usba_udc *udc, u32 mask)
 	udc->int_enb_cache = val;
 }
 
-static int vbus_is_present(struct usba_udc *udc)
-{
-	if (udc->vbus_pin)
-		return gpiod_get_value(udc->vbus_pin);
-
-	/* No Vbus detection: Assume always present */
-	return 1;
-}
-
-static int id_is_device(struct usba_udc *udc)
-{
-	if (gpio_is_valid(udc->id_pin))
-		return gpio_get_value(udc->id_pin);
-
-	/* No ID detection: Assume always device */
-	return 1;
-}
-
 static void toggle_bias(struct usba_udc *udc, int is_on)
 {
 	if (udc->errata && udc->errata->toggle_bias)
@@ -1928,14 +1911,6 @@ static irqreturn_t usba_udc_irq(int irq, void *devid)
 		usba_int_enb_set(udc, USBA_BF(EPT_INT, 1) | USBA_DET_SUSPEND |
 					      USBA_END_OF_RESUME);
 
-		/*
-		 * Unclear why we hit this irregularly, e.g. in usbtest,
-		 * but it's clearly harmless...
-		 */
-		if (!(usba_ep_readl(ep0, CFG) & USBA_EPT_MAPPED))
-			dev_err(&udc->pdev->dev,
-				"ODD: EP0 configuration is invalid!\n");
-
 		/* Preallocate other endpoints */
 		for (i = 1; i < udc->num_ep; i++) {
 			ep = &udc->usba_ep[i];
@@ -1998,6 +1973,9 @@ static int usba_start(struct usba_udc *udc)
 	unsigned long flags;
 	int ret;
 
+	if (udc->started)
+		return 0;
+
 	ret = start_clock(udc);
 	if (ret)
 		return ret;
@@ -2006,20 +1984,20 @@ static int usba_start(struct usba_udc *udc)
 		return 0;
 
 	spin_lock_irqsave(&udc->lock, flags);
-	dev_dbg(&udc->pdev->dev, "Enable bias\n");
 	toggle_bias(udc, 1);
-	dev_dbg(&udc->pdev->dev, "Switch to device\n");
+	dev_dbg(&udc->pdev->dev, "Enable device mode\n");
 	usba_writel(udc, CTRL, USBA_ENABLE_MASK);
 	/* Clear all requested and pending interrupts... */
 	usba_writel(udc, INT_ENB, 0);
 	udc->int_enb_cache = 0;
 	usba_writel(udc, INT_CLR,
-		    USBA_END_OF_RESET | USBA_END_OF_RESUME | USBA_DET_SUSPEND |
-			    USBA_WAKE_UP);
+		USBA_END_OF_RESET|USBA_END_OF_RESUME
+		|USBA_DET_SUSPEND|USBA_WAKE_UP);
 	/* ...and enable just 'reset' IRQ to get us started */
 	usba_int_enb_set(udc, USBA_END_OF_RESET);
 	spin_unlock_irqrestore(&udc->lock, flags);
 
+	udc->started = true;
 	return 0;
 }
 
@@ -2035,48 +2013,49 @@ static void usba_stop(struct usba_udc *udc)
 	reset_all_endpoints(udc);
 
 	/* This will also disable the DP pullup */
-	dev_dbg(&udc->pdev->dev, "Disable bias\n");
 	toggle_bias(udc, 0);
-	dev_dbg(&udc->pdev->dev, "Switch to host\n");
 	usba_writel(udc, CTRL, USBA_DISABLE_MASK);
 	spin_unlock_irqrestore(&udc->lock, flags);
 
 	stop_clock(udc);
+	udc->started = false;
+
+	dev_dbg(&udc->pdev->dev, "Disable device mode\n");
 }
 
-static irqreturn_t usba_vbus_irq_thread(int irq, void *devid)
+static int atmel_udc_usb_apply_role(struct device *dev)
 {
-	struct usba_udc *udc = devid;
-	int vbus;
-
-	/* debounce */
-	udelay(10);
-
-	mutex_lock(&udc->vbus_mutex);
-
-	vbus = vbus_is_present(udc);
-	dev_dbg(&udc->pdev->dev, "VBUS irq: %s\n",
-		vbus ? "power on" : "power off");
-	/* test level of ID pin */
-	dev_dbg(&udc->pdev->dev, "ID value: %s\n",
-		id_is_device(udc) ? "device" : "host");
-	if (vbus != udc->vbus_prev) {
-		if (vbus && id_is_device(udc)) {
-			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
-			usba_start(udc);
-		} else {
+	int ret = 0;
+	struct usba_udc *udc = dev_get_drvdata(dev);
+	unsigned long flags;
+
+	if (udc->role != udc->pending_role) {
+		dev_dbg(dev, "Apply pending role (%d -> %d)\n", udc->role,
+			udc->pending_role);
+
+		/* we leave device mode here */
+		if (udc->role == USB_ROLE_DEVICE) {
 			udc->suspended = false;
-			if (udc->driver->disconnect)
+			spin_lock_irqsave(&udc->lock, flags);
+			if (udc->driver && udc->driver->disconnect) {
+				dev_dbg(dev, "Execute gadget disconnect\n");
 				udc->driver->disconnect(&udc->gadget);
+			}
+			spin_unlock_irqrestore(&udc->lock, flags);
 
 			usba_stop(udc);
 			phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 0);
 		}
-		udc->vbus_prev = vbus;
+		udc->role = udc->pending_role;
 	}
 
-	mutex_unlock(&udc->vbus_mutex);
-	return IRQ_HANDLED;
+	/* in case we enter device mode even if it was pending */
+	if (udc->binded && udc->role == USB_ROLE_DEVICE) {
+		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
+		usba_start(udc);
+	}
+
+	return ret;
 }
 
 static int atmel_usba_pullup(struct usb_gadget *gadget, int is_on)
@@ -2102,48 +2081,28 @@ static int atmel_usba_start(struct usb_gadget *gadget,
 {
 	int ret;
 	struct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);
+	struct device *dev = &udc->pdev->dev;
 	unsigned long flags;
-	int id;
+
+	dev_dbg(dev, "atmel_usba_start\n");
 
 	spin_lock_irqsave(&udc->lock, flags);
 	udc->devstatus = 1 << USB_DEVICE_SELF_POWERED;
 	udc->driver = driver;
 	spin_unlock_irqrestore(&udc->lock, flags);
 
-	mutex_lock(&udc->vbus_mutex);
-
-	if (udc->vbus_pin)
-		enable_irq(gpiod_to_irq(udc->vbus_pin));
-
-	/* If Vbus is present, enable the controller and wait for reset */
-	udc->vbus_prev = vbus_is_present(udc);
-
-	/* Check ID pin status */
-	if (gpio_is_valid(udc->id_pin)) {
-		id = id_is_device(udc);
-		dev_dbg(&udc->pdev->dev, "ID value: %s\n",
-			id ? "device" : "host");
-	} else {
-		/* ID pin not valid, assuming device */
-		id = 1;
-	}
-
-	/* Only activate device mode if VBUS is present and ID is device */
-	if (udc->vbus_prev && id) {
-		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
-		ret = usba_start(udc);
-		if (ret)
-			goto err;
-	}
+	mutex_lock(&udc->role_sw_lock);
+	udc->binded = true;
+	ret = atmel_udc_usb_apply_role(dev);
+	if (ret < 0)
+		goto err;
 
-	mutex_unlock(&udc->vbus_mutex);
+	mutex_unlock(&udc->role_sw_lock);
 	return 0;
 
 err:
-	if (udc->vbus_pin)
-		disable_irq(gpiod_to_irq(udc->vbus_pin));
-
-	mutex_unlock(&udc->vbus_mutex);
+	udc->binded = false;
+	mutex_unlock(&udc->role_sw_lock);
 
 	spin_lock_irqsave(&udc->lock, flags);
 	udc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);
@@ -2156,8 +2115,9 @@ static int atmel_usba_stop(struct usb_gadget *gadget)
 {
 	struct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);
 
-	if (udc->vbus_pin)
-		disable_irq(gpiod_to_irq(udc->vbus_pin));
+	mutex_lock(&udc->role_sw_lock);
+	udc->binded = false;
+	mutex_unlock(&udc->role_sw_lock);
 
 	udc->suspended = false;
 	usba_stop(udc);
@@ -2289,7 +2249,6 @@ static const struct of_device_id atmel_pmc_dt_ids[] = {
 static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
 					 struct usba_udc *udc)
 {
-	enum of_gpio_flags flags;
 	struct device_node *np = pdev->dev.of_node;
 	const struct of_device_id *match;
 	struct device_node *pp;
@@ -2320,22 +2279,6 @@ static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
 
 	udc->num_ep = 0;
 
-	udc->vbus_pin =
-		devm_gpiod_get_optional(&pdev->dev, "atmel,vbus", GPIOD_IN);
-	if (IS_ERR(udc->vbus_pin)) {
-		ret = PTR_ERR(udc->vbus_pin);
-		dev_err(&pdev->dev, "unable to claim gpio \"vbus\": %d\n", ret);
-	}
-
-	udc->id_pin = of_get_named_gpio_flags(np, "atmel,id-gpio", 0, &flags);
-
-	if (gpio_is_valid(udc->id_pin)) {
-		dev_dbg(&udc->pdev->dev, "id pin: %s\n",
-			id_is_device(udc) ? "device" : "host");
-	} else {
-		dev_dbg(&udc->pdev->dev, "id pin not given or invalid\n");
-	}
-
 	if (fifo_mode == 0) {
 		udc->num_ep = udc_config->num_ep;
 	} else {
@@ -2440,63 +2383,101 @@ static struct usba_ep *atmel_udc_of_init(struct platform_device *pdev,
 	return ERR_PTR(ret);
 }
 
+static int atmel_udc_usb_set_role(struct usb_role_switch *sw,
+				  enum usb_role role)
+{
+	struct usba_udc *udc = usb_role_switch_get_drvdata(sw);
+	struct device *dev = &udc->pdev->dev;
+	int ret;
+
+	mutex_lock(&udc->role_sw_lock);
+	if (role != udc->pending_role) {
+		dev_dbg(dev,
+			"Request to change role, set pending to new role (%d)\n",
+			role);
+		udc->pending_role = role;
+	}
+	ret = atmel_udc_usb_apply_role(dev);
+	mutex_unlock(&udc->role_sw_lock);
+
+	return ret;
+}
+
+static enum usb_role atmel_udc_usb_get_role(struct usb_role_switch *sw)
+{
+	struct usba_udc *udc = usb_role_switch_get_drvdata(sw);
+	struct device *dev = &udc->pdev->dev;
+	enum usb_role role = USB_ROLE_NONE;
+
+	mutex_lock(&udc->role_sw_lock);
+	role = udc->role;
+	mutex_unlock(&udc->role_sw_lock);
+
+	dev_dbg(dev, "udc_get_role (%d)\n", role);
+
+	return role;
+}
+
 static int usba_udc_probe(struct platform_device *pdev)
 {
 	struct resource *res;
 	struct clk *pclk, *hclk;
 	struct usba_udc *udc;
+	struct device *dev = &pdev->dev;
+	struct usb_role_switch_desc atmel_udc_role_switch_desc = { NULL };
 	int irq, ret, i;
 
-	udc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);
+	udc = devm_kzalloc(dev, sizeof(*udc), GFP_KERNEL);
 	if (!udc)
 		return -ENOMEM;
 
-	dev_dbg(&pdev->dev, "Driver probing\n");
+	dev_dbg(dev, "usba_udc_probe\n");
 
 	udc->gadget = usba_gadget_template;
 	INIT_LIST_HEAD(&udc->gadget.ep_list);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);
-	udc->regs = devm_ioremap_resource(&pdev->dev, res);
+	udc->regs = devm_ioremap_resource(dev, res);
 	if (IS_ERR(udc->regs))
 		return PTR_ERR(udc->regs);
+
 	dev_info(&pdev->dev, "MMIO registers at %pR mapped at %p\n", res,
 		 udc->regs);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);
-	udc->fifo = devm_ioremap_resource(&pdev->dev, res);
+	udc->fifo = devm_ioremap_resource(dev, res);
 	if (IS_ERR(udc->fifo))
 		return PTR_ERR(udc->fifo);
-	dev_info(&pdev->dev, "FIFO at %pR mapped at %p\n", res, udc->fifo);
+	dev_info(dev, "FIFO at %pR mapped at %p\n", res, udc->fifo);
 
 	irq = platform_get_irq(pdev, 0);
 	if (irq < 0)
 		return irq;
 
-	pclk = devm_clk_get(&pdev->dev, "pclk");
+	pclk = devm_clk_get(dev, "pclk");
 	if (IS_ERR(pclk))
 		return PTR_ERR(pclk);
-	hclk = devm_clk_get(&pdev->dev, "hclk");
+	hclk = devm_clk_get(dev, "hclk");
 	if (IS_ERR(hclk))
 		return PTR_ERR(hclk);
 
 	spin_lock_init(&udc->lock);
-	mutex_init(&udc->vbus_mutex);
+	mutex_init(&udc->role_sw_lock);
+	udc->binded = false;
+	udc->started = false;
 	udc->pdev = pdev;
 	udc->pclk = pclk;
 	udc->hclk = hclk;
-	udc->id_pin = -ENODEV;
 
 	platform_set_drvdata(pdev, udc);
 
 	/* Make sure we start from a clean slate */
 	ret = clk_prepare_enable(pclk);
 	if (ret) {
-		dev_err(&pdev->dev, "Unable to enable pclk, aborting.\n");
+		dev_err(dev, "Unable to enable pclk, aborting.\n");
 		return ret;
 	}
 
-	dev_dbg(&pdev->dev, "Switch to host by default\n");
 	usba_writel(udc, CTRL, USBA_DISABLE_MASK);
 	clk_disable_unprepare(pclk);
 
@@ -2520,122 +2501,86 @@ static int usba_udc_probe(struct platform_device *pdev)
 	}
 	udc->irq = irq;
 
-	if (udc->vbus_pin) {
-		irq_set_status_flags(gpiod_to_irq(udc->vbus_pin), IRQ_NOAUTOEN);
-		ret = devm_request_threaded_irq(&pdev->dev,
-						gpiod_to_irq(udc->vbus_pin),
-						NULL, usba_vbus_irq_thread,
-						USBA_VBUS_IRQFLAGS,
-						"atmel_usba_udc", udc);
-		if (ret) {
-			udc->vbus_pin = NULL;
-			dev_warn(&udc->pdev->dev, "failed to request vbus irq; "
-						  "assuming always on\n");
-		}
-	}
-
-	ret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);
+	ret = usb_add_gadget_udc(dev, &udc->gadget);
 	if (ret)
 		return ret;
-	device_init_wakeup(&pdev->dev, 1);
+	device_init_wakeup(dev, 1);
 
 	usba_init_debugfs(udc);
 	for (i = 1; i < udc->num_ep; i++)
 		usba_ep_init_debugfs(udc, &udc->usba_ep[i]);
 
-	return 0;
-}
-
-static int usba_udc_remove(struct platform_device *pdev)
-{
-	struct usba_udc *udc;
-	int i;
-
-	udc = platform_get_drvdata(pdev);
-
-	device_init_wakeup(&pdev->dev, 0);
-	usb_del_gadget_udc(&udc->gadget);
-
-	for (i = 1; i < udc->num_ep; i++)
-		usba_ep_cleanup_debugfs(&udc->usba_ep[i]);
-	usba_cleanup_debugfs(udc);
-
-	return 0;
-}
-
-#ifdef CONFIG_PM_SLEEP
-static int usba_udc_suspend(struct device *dev)
-{
-	struct usba_udc *udc = dev_get_drvdata(dev);
-
-	dev_dbg(&udc->pdev->dev, "Power suspend\n");
+	udc->role = USB_ROLE_NONE;
+	if (device_property_read_bool(&pdev->dev, "usb-role-switch")) {
+		atmel_udc_role_switch_desc.fwnode = dev_fwnode(dev);
+		atmel_udc_role_switch_desc.get = atmel_udc_usb_get_role;
+		atmel_udc_role_switch_desc.set = atmel_udc_usb_set_role;
+		atmel_udc_role_switch_desc.driver_data = udc;
+		atmel_udc_role_switch_desc.userspace_enable = true;
+		atmel_udc_role_switch_desc.userspace_allow_write = false;
+
+		dev_info(dev, "Registering as USB role switch controller\n");
+		udc->role_sw = usb_role_switch_register(
+			dev, &atmel_udc_role_switch_desc);
+		if (IS_ERR(udc->role_sw)) {
+			dev_err(dev, "usb role sw register failed: %ld\n",
+				PTR_ERR(udc->role_sw));
+
+			usb_del_gadget_udc(&udc->gadget);
+
+			for (i = 1; i < udc->num_ep; i++)
+				usba_ep_cleanup_debugfs(&udc->usba_ep[i]);
+			usba_cleanup_debugfs(udc);
+
+			return PTR_ERR(udc->role_sw);
+		}
+	}
 
-	/* Not started */
-	if (!udc->driver)
-		return 0;
+	if (dev->of_node) {
+		ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
+		if (ret < 0) {
+			dev_err(dev, "failed to populate DT children\n");
 
-	mutex_lock(&udc->vbus_mutex);
+			usb_role_switch_unregister(udc->role_sw);
 
-	if (!device_may_wakeup(dev)) {
-		udc->suspended = false;
-		usba_stop(udc);
-		goto out;
-	}
+			device_init_wakeup(dev, 0);
+			usb_del_gadget_udc(&udc->gadget);
 
-	/*
-	 * Device may wake up. We stay clocked if we failed
-	 * to request vbus irq, assuming always on.
-	 */
-	if (udc->vbus_pin) {
-		/* FIXME: right to stop here...??? */
-		usba_stop(udc);
-		enable_irq_wake(gpiod_to_irq(udc->vbus_pin));
+			for (i = 1; i < udc->num_ep; i++)
+				usba_ep_cleanup_debugfs(&udc->usba_ep[i]);
+			usba_cleanup_debugfs(udc);
+		}
 	}
 
-	enable_irq_wake(udc->irq);
-
-out:
-	mutex_unlock(&udc->vbus_mutex);
 	return 0;
 }
 
-static int usba_udc_resume(struct device *dev)
+static int usba_udc_remove(struct platform_device *pdev)
 {
-	struct usba_udc *udc = dev_get_drvdata(dev);
+	struct usba_udc *udc;
+	struct device *dev = &pdev->dev;
+	int i;
 
-	dev_dbg(&udc->pdev->dev, "Power resume\n");
+	udc = platform_get_drvdata(pdev);
 
-	/* Not started */
-	if (!udc->driver)
-		return 0;
+	dev_dbg(dev, "usba_udc_remove\n");
 
-	if (device_may_wakeup(dev)) {
-		if (udc->vbus_pin)
-			disable_irq_wake(gpiod_to_irq(udc->vbus_pin));
+	usb_role_switch_unregister(udc->role_sw);
 
-		disable_irq_wake(udc->irq);
-	}
+	device_init_wakeup(dev, 0);
+	usb_del_gadget_udc(&udc->gadget);
 
-	/* If Vbus is present, enable the controller and wait for reset */
-	mutex_lock(&udc->vbus_mutex);
-	udc->vbus_prev = vbus_is_present(udc);
-	if (udc->vbus_prev) {
-		phy_set_mode_ext(udc->phy, PHY_MODE_USB_DEVICE, 1);
-		usba_start(udc);
-	}
-	mutex_unlock(&udc->vbus_mutex);
+	for (i = 1; i < udc->num_ep; i++)
+		usba_ep_cleanup_debugfs(&udc->usba_ep[i]);
+	usba_cleanup_debugfs(udc);
 
 	return 0;
 }
-#endif
-
-static SIMPLE_DEV_PM_OPS(usba_udc_pm_ops, usba_udc_suspend, usba_udc_resume);
 
 static struct platform_driver udc_driver = {
 	.remove		= usba_udc_remove,
 	.driver		= {
 		.name		= "atmel_usba_udc",
-		.pm		= &usba_udc_pm_ops,
 		.of_match_table	= atmel_udc_dt_ids,
 	},
 };
diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.h b/drivers/usb/gadget/udc/atmel_usba_udc.h
index 37771b16b4f3..1081075f9a9c 100644
--- a/drivers/usb/gadget/udc/atmel_usba_udc.h
+++ b/drivers/usb/gadget/udc/atmel_usba_udc.h
@@ -9,6 +9,7 @@
 
 #include <linux/gpio/consumer.h>
 #include <linux/phy/phy.h>
+#include <linux/usb/role.h>
 
 /* USB register offsets */
 #define USBA_CTRL				0x0000
@@ -325,19 +326,21 @@ struct usba_udc {
 	/* Protect hw registers from concurrent modifications */
 	spinlock_t lock;
 
-	/* Mutex to prevent concurrent start or stop */
-	struct mutex vbus_mutex;
-
 	void __iomem *regs;
 	void __iomem *fifo;
 
+	struct mutex role_sw_lock;
+	struct usb_role_switch *role_sw;
+	enum usb_role role;
+	enum usb_role pending_role;
+	bool binded;
+	bool started;
+
 	struct usb_gadget gadget;
 	struct usb_gadget_driver *driver;
 	struct platform_device *pdev;
 	const struct usba_udc_errata *errata;
 	int irq;
-	struct gpio_desc *vbus_pin;
-	int id_pin;
 	int num_ep;
 	struct usba_fifo_cfg *fifo_cfg;
 	struct clk *pclk;
@@ -351,7 +354,6 @@ struct usba_udc {
 	u16 devstatus;
 
 	u16 test_mode;
-	int vbus_prev;
 
 	u32 int_enb_cache;
 
diff --git a/include/linux/mfd/wgw-ec/usbc.h b/include/linux/mfd/wgw-ec/usbc.h
index 2ccfd52642db..dd5e01c3e058 100644
--- a/include/linux/mfd/wgw-ec/usbc.h
+++ b/include/linux/mfd/wgw-ec/usbc.h
@@ -19,6 +19,7 @@
 
 #include <linux/of.h>
 #include <linux/notifier.h>
+#include <linux/usb/role.h>
 #include <linux/usb/typec.h>
 
 #include <linux/mfd/wgw-ec/core.h>
@@ -40,26 +41,36 @@ struct wgw_ec_usbc_dev {
 	struct device *dev;
 	struct wgw_ec_dev *ec;
 
-	spinlock_t lock;
-
+	// notification from wgw-ec-dev
 	struct notifier_block notifier;
-	struct blocking_notifier_head notifier_list;
 
-	enum usb_data_mode data_mode;
-	enum usb_power_mode power_mode;
+	// keep track of all wgw-ec-usbc-dev
+	struct list_head list_node;
 
 	struct typec_port *port;
 	struct typec_partner *partner;
 	struct typec_capability typec_cap;
+	struct usb_role_switch *role_sw;
+
+	// cache
+	spinlock_t lock;
+	enum usb_data_mode data_mode;
+	enum usb_power_mode power_mode;
 };
 
-/* Events from the usb core */
-#define WGW_USBC_DATA_MODE_CHANGE 0x0001
-#define WGW_USBC_POWER_MODE_CHANGE 0x0002
+/* Events and notification from the usb core */
+#define WGW_USBC_DEVICE_PROBE		0x0001
+#define WGW_USBC_NOTIFIER_UPDATE	0x0002
+#define WGW_USBC_DATA_MODE_CHANGE	0x0003
+#define WGW_USBC_POWER_MODE_CHANGE	0x0004
+
+struct wgw_ec_usbc_notification {
+	struct device *dev;
+	enum usb_power_mode power_mode;
+	enum usb_data_mode data_mode;
+};
 
-extern enum usb_data_mode
-wgw_ec_usbc_get_data_mode(struct wgw_ec_usbc_dev *usbc);
-extern enum usb_power_mode
-wgw_ec_usbc_get_power_mode(struct wgw_ec_usbc_dev *usbc);
+int wgw_ec_usbc_register_notifier(struct notifier_block *nb);
+int wgw_ec_usbc_unregister_notifier(struct notifier_block *nb);
 
-#endif /* __LINUX_MFD_WGW_EC_LED_H */
+#endif /* __LINUX_MFD_WGW_EC_USBC_H */
-- 
2.34.1

