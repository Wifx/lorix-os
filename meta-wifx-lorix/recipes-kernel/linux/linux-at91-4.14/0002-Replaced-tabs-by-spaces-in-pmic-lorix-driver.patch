From 98a8bfa229901e3e0fb3534389a9b46ec6bd0645 Mon Sep 17 00:00:00 2001
From: Yannick Lanz <yannick.lanz@wifx.net>
Date: Tue, 30 Jul 2019 10:42:18 +0200
Subject: [PATCH 2/4] Replaced tabs by spaces in pmic-lorix driver

---
 drivers/mfd/pmic-lorix.c       | 562 ++++++++++++++++-----------------
 include/linux/mfd/pmic-lorix.h |  34 +-
 2 files changed, 298 insertions(+), 298 deletions(-)

diff --git a/drivers/mfd/pmic-lorix.c b/drivers/mfd/pmic-lorix.c
index ed28afd65c32..917d51d96b8c 100644
--- a/drivers/mfd/pmic-lorix.c
+++ b/drivers/mfd/pmic-lorix.c
@@ -27,10 +27,10 @@
 #define REG_FEATURE2                0x0B
 
 static struct mfd_cell pmic_lorix_devs[] = {
-	{
-		.name = "pmic-lorix-led",
-		.of_compatible = "wifx,pmic-lorix-led",
-	},
+    {
+        .name = "pmic-lorix-led",
+        .of_compatible = "wifx,pmic-lorix-led",
+    },
 };
 
 typedef struct __attribute__((packed, aligned(1))){
@@ -62,65 +62,65 @@ static reg_features1_t reg_features1 = { .raw = 0x00 };
 static reg_features2_t reg_features2 = { .raw = 0x00 };
 
 static int __lorix_read(struct i2c_client *client,
-				int reg, uint8_t *val)
+                int reg, uint8_t *val)
 {
-	int ret;
+    int ret;
 
-	ret = i2c_smbus_read_byte_data(client, reg);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
-		return ret;
-	}
+    ret = i2c_smbus_read_byte_data(client, reg);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed reading at 0x%02x\n", reg);
+        return ret;
+    }
 
-	*val = (uint8_t)ret;
-	return 0;
+    *val = (uint8_t)ret;
+    return 0;
 }
 
 static int __lorix_write(struct i2c_client *client,
-				 int reg, uint8_t val)
+                 int reg, uint8_t val)
 {
-	int ret;
-
-	ret = i2c_smbus_write_byte_data(client, reg, val);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
-				val, reg);
-		return ret;
-	}
-	return 0;
+    int ret;
+
+    ret = i2c_smbus_write_byte_data(client, reg, val);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed writing 0x%02x to 0x%02x\n",
+                val, reg);
+        return ret;
+    }
+    return 0;
 }
 
 int pmic_lorix_write(struct attiny *attiny, int reg, uint8_t val)
 {
-	int ret;
-	mutex_lock(&attiny->lock);
+    int ret;
+    mutex_lock(&attiny->lock);
 
-	ret = __lorix_write(attiny->client, reg, val);
+    ret = __lorix_write(attiny->client, reg, val);
 
-	mutex_unlock(&attiny->lock);
-	return ret;
+    mutex_unlock(&attiny->lock);
+    return ret;
 }
 EXPORT_SYMBOL(pmic_lorix_write);
 
 int pmic_lorix_read(struct attiny *attiny, int reg, uint8_t *val)
 {
-	int ret;
-	mutex_lock(&attiny->lock);
+    int ret;
+    mutex_lock(&attiny->lock);
 
-	ret = __lorix_read(attiny->client, reg, val);
+    ret = __lorix_read(attiny->client, reg, val);
 
-	mutex_unlock(&attiny->lock);
-	return ret;
+    mutex_unlock(&attiny->lock);
+    return ret;
 }
 EXPORT_SYMBOL(pmic_lorix_read);
 
 static int boot_state_get(struct attiny *attiny, uint8_t *boot_state)
 {
-	int ret = pmic_lorix_read(attiny, REG_LAST_RESET_STATE, boot_state);
-	if (ret < 0)
-		*boot_state = 0xFF;
+    int ret = pmic_lorix_read(attiny, REG_LAST_RESET_STATE, boot_state);
+    if (ret < 0)
+        *boot_state = 0xFF;
 
-	return ret;
+    return ret;
 }
 
 static int boot_state_clr(struct attiny *attiny)
@@ -130,110 +130,110 @@ static int boot_state_clr(struct attiny *attiny)
 
 static int fw_version_get(struct attiny *attiny, char *str)
 {
-	int ret;
-	uint8_t len;
-	char tmp[10];
-
-	mutex_lock(&attiny->lock);
-
-	ret = i2c_smbus_read_byte_data(attiny->client, REG_FW_VERSION_LENGTH);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register FW_VERSION_LENGTH\n");
-		goto out_err_read;
-	}
-	len = (uint8_t)ret;
-	if (len > 10) {
-		dev_err(attiny->dev, "error with FW version length (length read = %d)\n", len);
-		goto out_err_read;
-	}
-
-	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_FW_VERSION, (uint8_t)ret, tmp);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register FW_VERSION\n");
-		goto out_err_read;
-	}
-
-	mutex_unlock(&attiny->lock);
-
-	strncpy(str, tmp, len);
-	return (int)len;
+    int ret;
+    uint8_t len;
+    char tmp[10];
+
+    mutex_lock(&attiny->lock);
+
+    ret = i2c_smbus_read_byte_data(attiny->client, REG_FW_VERSION_LENGTH);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register FW_VERSION_LENGTH\n");
+        goto out_err_read;
+    }
+    len = (uint8_t)ret;
+    if (len > 10) {
+        dev_err(attiny->dev, "error with FW version length (length read = %d)\n", len);
+        goto out_err_read;
+    }
+
+    ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_FW_VERSION, (uint8_t)ret, tmp);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register FW_VERSION\n");
+        goto out_err_read;
+    }
+
+    mutex_unlock(&attiny->lock);
+
+    strncpy(str, tmp, len);
+    return (int)len;
 
 out_err_read:
-	dev_err(attiny->dev, "failed retrieving FW version\n");
-	mutex_unlock(&attiny->lock);
-	return -EIO;
+    dev_err(attiny->dev, "failed retrieving FW version\n");
+    mutex_unlock(&attiny->lock);
+    return -EIO;
 }
 
 static int hw_version_get(struct attiny *attiny, char *str)
 {
-	int ret;
-	uint8_t len;
-	char tmp[10];
-
-	mutex_lock(&attiny->lock);
-
-	ret = i2c_smbus_read_byte_data(attiny->client, REG_HW_VERSION_LENGTH);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register HW_VERSION_LENGTH\n");
-		goto out_err_read;
-	}
-	len = (uint8_t)ret;
-	if (len > 10) {
-		dev_err(attiny->dev, "error with HW version length (length read = %d)\n", len);
-		goto out_err_read;
-	}
-
-	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_HW_VERSION, (uint8_t)ret, tmp);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register HW_VERSION\n");
-		goto out_err_read;
-	}
-
-	mutex_unlock(&attiny->lock);
-
-	strncpy(str, tmp, len);
-	return (int)len;
+    int ret;
+    uint8_t len;
+    char tmp[10];
+
+    mutex_lock(&attiny->lock);
+
+    ret = i2c_smbus_read_byte_data(attiny->client, REG_HW_VERSION_LENGTH);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register HW_VERSION_LENGTH\n");
+        goto out_err_read;
+    }
+    len = (uint8_t)ret;
+    if (len > 10) {
+        dev_err(attiny->dev, "error with HW version length (length read = %d)\n", len);
+        goto out_err_read;
+    }
+
+    ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_HW_VERSION, (uint8_t)ret, tmp);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register HW_VERSION\n");
+        goto out_err_read;
+    }
+
+    mutex_unlock(&attiny->lock);
+
+    strncpy(str, tmp, len);
+    return (int)len;
 
 out_err_read:
-	dev_err(attiny->dev, "failed retrieving HW version\n");
-	mutex_unlock(&attiny->lock);
-	return -EIO;
+    dev_err(attiny->dev, "failed retrieving HW version\n");
+    mutex_unlock(&attiny->lock);
+    return -EIO;
 }
 
 static int product_name_get(struct attiny *attiny, char *str)
 {
-	int ret;
-	uint8_t len;
-	char tmp[16];
-
-	mutex_lock(&attiny->lock);
-
-	ret = i2c_smbus_read_byte_data(attiny->client, REG_PRODUCT_NAME_LENGTH);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register PRODUCT_NAME_LENGTH\n");
-		goto out_err_read;
-	}
-	len = (uint8_t)ret;
-	if (len > 16) {
-		dev_err(attiny->dev, "error with product name length (length read = %d)\n", len);
-		goto out_err_read;
-	}
-
-	ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_PRODUCT_NAME, (uint8_t)ret, tmp);
-	if (ret < 0) {
-		dev_err(attiny->dev, "failed reading register PRODUCT_NAME\n");
-		goto out_err_read;
-	}
-
-	mutex_unlock(&attiny->lock);
-
-	strncpy(str, tmp, len);
-	return (int)len;
+    int ret;
+    uint8_t len;
+    char tmp[16];
+
+    mutex_lock(&attiny->lock);
+
+    ret = i2c_smbus_read_byte_data(attiny->client, REG_PRODUCT_NAME_LENGTH);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register PRODUCT_NAME_LENGTH\n");
+        goto out_err_read;
+    }
+    len = (uint8_t)ret;
+    if (len > 16) {
+        dev_err(attiny->dev, "error with product name length (length read = %d)\n", len);
+        goto out_err_read;
+    }
+
+    ret = i2c_smbus_read_i2c_block_data(attiny->client, REG_PRODUCT_NAME, (uint8_t)ret, tmp);
+    if (ret < 0) {
+        dev_err(attiny->dev, "failed reading register PRODUCT_NAME\n");
+        goto out_err_read;
+    }
+
+    mutex_unlock(&attiny->lock);
+
+    strncpy(str, tmp, len);
+    return (int)len;
 
 out_err_read:
-	dev_err(attiny->dev, "failed retrieving product name\n");
-	mutex_unlock(&attiny->lock);
-	return -EIO;
+    dev_err(attiny->dev, "failed retrieving product name\n");
+    mutex_unlock(&attiny->lock);
+    return -EIO;
 }
 
 static int product_type_get(struct attiny *attiny, char *str)
@@ -291,13 +291,13 @@ static int reg_feature2_get(struct attiny *attiny, reg_features2_t *reg_feature2
 }
 
 static ssize_t boot_state_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+                struct device_attribute *attr, char *buf)
 {
-	struct attiny *attiny = dev_get_drvdata(dev);
-	uint8_t boot_state;
+    struct attiny *attiny = dev_get_drvdata(dev);
+    uint8_t boot_state;
 
-	boot_state_get(attiny, &boot_state);
-	return sprintf(buf, "%d\n", boot_state);
+    boot_state_get(attiny, &boot_state);
+    return sprintf(buf, "%d\n", boot_state);
 }
 
 static ssize_t boot_state_store(struct device *dev,
@@ -315,33 +315,33 @@ static ssize_t boot_state_store(struct device *dev,
 }
 
 static ssize_t fw_version_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+                struct device_attribute *attr, char *buf)
 {
-	struct attiny *attiny = dev_get_drvdata(dev);
-	char fw_ver[10];
-	int ret;
-
-	ret = fw_version_get(attiny, fw_ver);
-	if (ret < 0) {
-		return sprintf(buf, "unknown\n");
-	} else {
-		return sprintf(buf, "%s\n", fw_ver);
-	}
+    struct attiny *attiny = dev_get_drvdata(dev);
+    char fw_ver[10];
+    int ret;
+
+    ret = fw_version_get(attiny, fw_ver);
+    if (ret < 0) {
+        return sprintf(buf, "unknown\n");
+    } else {
+        return sprintf(buf, "%s\n", fw_ver);
+    }
 }
 
 static ssize_t hw_version_show(struct device *dev,
-				struct device_attribute *attr, char *buf)
+                struct device_attribute *attr, char *buf)
 {
-	struct attiny *attiny = dev_get_drvdata(dev);
-	char hw_ver[10];
-	int ret;
-
-	ret = hw_version_get(attiny, hw_ver);
-	if (ret < 0) {
-		return sprintf(buf, "unknown\n");
-	} else {
-		return sprintf(buf, "%s\n", hw_ver);
-	}
+    struct attiny *attiny = dev_get_drvdata(dev);
+    char hw_ver[10];
+    int ret;
+
+    ret = hw_version_get(attiny, hw_ver);
+    if (ret < 0) {
+        return sprintf(buf, "unknown\n");
+    } else {
+        return sprintf(buf, "%s\n", hw_ver);
+    }
 }
 
 static ssize_t product_name_show(struct device *dev,
@@ -381,71 +381,71 @@ static DEVICE_ATTR(product_name, S_IRUGO, product_name_show, NULL);
 static DEVICE_ATTR(product_type, S_IRUGO, product_type_show, NULL);
 
 static int pmic_lorix_probe(struct i2c_client *client,
-							const struct i2c_device_id *id)
+                            const struct i2c_device_id *id)
 {
 
-	struct attiny_platform_data *pdata = dev_get_platdata(&client->dev);
-	//struct platform_device *pdev;
-	struct attiny *attiny;
-	struct device *dev = &client->dev;
-	int ret;
-	uint8_t boot_state;
-	char fw_ver[10], hw_ver[10], name[16], type[16];
-	char *ptr;
-
-	if (!i2c_check_functionality(client->adapter,
-					I2C_FUNC_SMBUS_BYTE_DATA)) {
-		dev_err(dev, "SMBUS Word Data not Supported\n");
-		return -EIO;
-	}
-
-	// creating the driver data
-	attiny = devm_kzalloc(&client->dev, sizeof(*attiny), GFP_KERNEL);
-	if (!attiny) {
-		dev_err(dev, "Memory allocation failed\n");
-		return -ENOMEM;
-	}
-
-	// assign driver data to device
-	dev_set_drvdata(&client->dev, attiny);
-	attiny->client = client;
-	attiny->dev = &client->dev;
-	attiny->id = id->driver_data;
-
-	// init the device lock
-	mutex_init(&attiny->lock);
-
-	if (pdata) {
-		pmic_lorix_devs[0].platform_data = &pdata->leds;
-		pmic_lorix_devs[0].pdata_size = sizeof(pdata->leds);
-	} else {
-		pmic_lorix_devs[0].platform_data = NULL;
-		pmic_lorix_devs[0].pdata_size = 0;
-	}
-	ret = mfd_add_devices(&client->dev, -1, (const struct mfd_cell *)&pmic_lorix_devs, 1, NULL, 0, NULL);
-
-	if (ret < 0) {
-		dev_err(&client->dev, "add mfd devices failed: %d\n", ret);
-		return ret;
-	}
-
-	// create sysfs entry
-	ret = device_create_file(&client->dev, &dev_attr_boot_state);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to add BOOT_STATE sysfs file\n");
-		goto out_remove_device;
-	}
-	ret = device_create_file(&client->dev, &dev_attr_fw_version);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to add FW_VERSION sysfs file\n");
-		goto out_remove_file_boot_state;
-	}
-	ret = device_create_file(&client->dev, &dev_attr_hw_version);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to add HW_VERSION sysfs file\n");
-		goto out_remove_file_fw_version;
-	}
-	ret = device_create_file(&client->dev, &dev_attr_product_name);
+    struct attiny_platform_data *pdata = dev_get_platdata(&client->dev);
+    //struct platform_device *pdev;
+    struct attiny *attiny;
+    struct device *dev = &client->dev;
+    int ret;
+    uint8_t boot_state;
+    char fw_ver[10], hw_ver[10], name[16], type[16];
+    char *ptr;
+
+    if (!i2c_check_functionality(client->adapter,
+                    I2C_FUNC_SMBUS_BYTE_DATA)) {
+        dev_err(dev, "SMBUS Word Data not Supported\n");
+        return -EIO;
+    }
+
+    // creating the driver data
+    attiny = devm_kzalloc(&client->dev, sizeof(*attiny), GFP_KERNEL);
+    if (!attiny) {
+        dev_err(dev, "Memory allocation failed\n");
+        return -ENOMEM;
+    }
+
+    // assign driver data to device
+    dev_set_drvdata(&client->dev, attiny);
+    attiny->client = client;
+    attiny->dev = &client->dev;
+    attiny->id = id->driver_data;
+
+    // init the device lock
+    mutex_init(&attiny->lock);
+
+    if (pdata) {
+        pmic_lorix_devs[0].platform_data = &pdata->leds;
+        pmic_lorix_devs[0].pdata_size = sizeof(pdata->leds);
+    } else {
+        pmic_lorix_devs[0].platform_data = NULL;
+        pmic_lorix_devs[0].pdata_size = 0;
+    }
+    ret = mfd_add_devices(&client->dev, -1, (const struct mfd_cell *)&pmic_lorix_devs, 1, NULL, 0, NULL);
+
+    if (ret < 0) {
+        dev_err(&client->dev, "add mfd devices failed: %d\n", ret);
+        return ret;
+    }
+
+    // create sysfs entry
+    ret = device_create_file(&client->dev, &dev_attr_boot_state);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to add BOOT_STATE sysfs file\n");
+        goto out_remove_device;
+    }
+    ret = device_create_file(&client->dev, &dev_attr_fw_version);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to add FW_VERSION sysfs file\n");
+        goto out_remove_file_boot_state;
+    }
+    ret = device_create_file(&client->dev, &dev_attr_hw_version);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to add HW_VERSION sysfs file\n");
+        goto out_remove_file_fw_version;
+    }
+    ret = device_create_file(&client->dev, &dev_attr_product_name);
     if (ret < 0) {
         dev_err(&client->dev, "failed to add NAME sysfs file\n");
         goto out_remove_file_hw_version;
@@ -458,55 +458,55 @@ static int pmic_lorix_probe(struct i2c_client *client,
 
     // FW version, HW version and boot state work in all cases since revision 1.0c
 
-	// read FW version
-	ret = fw_version_get(attiny, fw_ver);
-	if (ret < 0) {
-	    dev_err(&client->dev, "failed to retrieve FW version from pmic-lorix\n");
-		goto out_remove_all;
-	}
-
-	// read bootstate
-	ret = boot_state_get(attiny, &boot_state);
-	if (ret < 0) {
-		dev_err(&client->dev, "failed to retrieve boot_state from pmic-lorix\n");
-		goto out_remove_all;
-	}
-
-	// read HW version
-	ret = hw_version_get(attiny, hw_ver);
-	if (ret < 0) {
-	    dev_err(&client->dev, "failed to retrieve HW version from pmic-lorix\n");
-		goto out_remove_all;
-	}
-
-	// values by default
-	ptr = strcpy(name, "LORIX One");
-	ptr = strcpy(type, "EU868");
-
-	// test if features regs can be read
-	ret = reg_feature1_get(attiny, &reg_features1);
-	if (ret < 0 || reg_features1.bit.FEAT_LEGACY) {
-	    reg_features1.bit.FEAT_BOOT = 1;
-	    reg_features1.bit.FEAT_FW_VER = 1;
-	    reg_features1.bit.FEAT_HW_VER = 1;
-	    reg_features1.bit.FEAT_NAME = 0;
+    // read FW version
+    ret = fw_version_get(attiny, fw_ver);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to retrieve FW version from pmic-lorix\n");
+        goto out_remove_all;
+    }
+
+    // read bootstate
+    ret = boot_state_get(attiny, &boot_state);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to retrieve boot_state from pmic-lorix\n");
+        goto out_remove_all;
+    }
+
+    // read HW version
+    ret = hw_version_get(attiny, hw_ver);
+    if (ret < 0) {
+        dev_err(&client->dev, "failed to retrieve HW version from pmic-lorix\n");
+        goto out_remove_all;
+    }
+
+    // values by default
+    ptr = strcpy(name, "LORIX One");
+    ptr = strcpy(type, "EU868");
+
+    // test if features regs can be read
+    ret = reg_feature1_get(attiny, &reg_features1);
+    if (ret < 0 || reg_features1.bit.FEAT_LEGACY) {
+        reg_features1.bit.FEAT_BOOT = 1;
+        reg_features1.bit.FEAT_FW_VER = 1;
+        reg_features1.bit.FEAT_HW_VER = 1;
+        reg_features1.bit.FEAT_NAME = 0;
         reg_features1.bit.FEAT_TYPE = 0;
         reg_features1.bit.FEAT_PROG = 0;
-	}
+    }
 
-	// unused actually
-	ret = reg_feature2_get(attiny, &reg_features2);
+    // unused actually
+    ret = reg_feature2_get(attiny, &reg_features2);
 
-	// read product name if possible
-	if (reg_features1.bit.FEAT_NAME) {
-	    ret = product_name_get(attiny, name);
+    // read product name if possible
+    if (reg_features1.bit.FEAT_NAME) {
+        ret = product_name_get(attiny, name);
         if (ret < 0) {
             dev_err(&client->dev, "failed to retrieve product name from pmic-lorix\n");
             goto out_remove_all;
         }
-	}
+    }
 
-	// read product type if possible
+    // read product type if possible
     if (reg_features1.bit.FEAT_TYPE) {
         ret = product_type_get(attiny, type);
         if (ret < 0) {
@@ -533,7 +533,7 @@ static int pmic_lorix_probe(struct i2c_client *client,
         break;
     }
 
-	return 0;
+    return 0;
 
 out_remove_all:
 out_remove_file_product_type:
@@ -543,65 +543,65 @@ static int pmic_lorix_probe(struct i2c_client *client,
     device_remove_file(&client->dev, &dev_attr_product_name);
 
 out_remove_file_hw_version:
-	device_remove_file(&client->dev, &dev_attr_hw_version);
+    device_remove_file(&client->dev, &dev_attr_hw_version);
 
 out_remove_file_fw_version:
-	device_remove_file(&client->dev, &dev_attr_fw_version);
+    device_remove_file(&client->dev, &dev_attr_fw_version);
 
 out_remove_file_boot_state:
-	device_remove_file(&client->dev, &dev_attr_boot_state);
+    device_remove_file(&client->dev, &dev_attr_boot_state);
 
 out_remove_device:
-	mfd_remove_devices(&client->dev);
+    mfd_remove_devices(&client->dev);
 
-	return ret;
+    return ret;
 }
 
 static int pmic_lorix_remove(struct i2c_client *client)
 {
-	device_remove_file(&client->dev, &dev_attr_hw_version);
-	device_remove_file(&client->dev, &dev_attr_fw_version);
-	device_remove_file(&client->dev, &dev_attr_boot_state);
-	mfd_remove_devices(&client->dev);
+    device_remove_file(&client->dev, &dev_attr_hw_version);
+    device_remove_file(&client->dev, &dev_attr_fw_version);
+    device_remove_file(&client->dev, &dev_attr_boot_state);
+    mfd_remove_devices(&client->dev);
 
-	return 0;
+    return 0;
 }
 
 static const struct i2c_device_id pmic_lorix_id[] = {
-	{"pmic-lorix", 0},
-	{}
+    {"pmic-lorix", 0},
+    {}
 };
 MODULE_DEVICE_TABLE(i2c, pmic_lorix_id);
 
 #ifdef CONFIG_OF
 static const struct of_device_id pmic_lorix_of_match[] = {
-	{ .compatible = "wifx,pmic-lorix", },
-	{},
+    { .compatible = "wifx,pmic-lorix", },
+    {},
 };
 MODULE_DEVICE_TABLE(of, pmic_lorix_of_match);
 #endif
 
 static struct i2c_driver pmic_lorix_driver = {
-	.probe		= pmic_lorix_probe,
-	.remove		= pmic_lorix_remove,
-	.driver = {
-		.name	= "pmic-lorix",
-		.of_match_table = of_match_ptr(pmic_lorix_of_match),
-	},
-	.id_table 	= pmic_lorix_id,
+    .probe        = pmic_lorix_probe,
+    .remove        = pmic_lorix_remove,
+    .driver = {
+        .name    = "pmic-lorix",
+        .of_match_table = of_match_ptr(pmic_lorix_of_match),
+    },
+    .id_table     = pmic_lorix_id,
 };
 //module_i2c_driver(pmic_lorix_driver);
 
 static int __init pmic_lorix_i2c_init(void)
 {
-	return i2c_add_driver(&pmic_lorix_driver);
+    return i2c_add_driver(&pmic_lorix_driver);
 }
 /* init early so consumer devices can complete system boot */
 subsys_initcall(pmic_lorix_i2c_init);
 
 static void __exit pmic_lorix_i2c_exit(void)
 {
-	i2c_del_driver(&pmic_lorix_driver);
+    i2c_del_driver(&pmic_lorix_driver);
 }
 module_exit(pmic_lorix_i2c_exit);
 
diff --git a/include/linux/mfd/pmic-lorix.h b/include/linux/mfd/pmic-lorix.h
index bd6921035bac..459f9d0729ad 100644
--- a/include/linux/mfd/pmic-lorix.h
+++ b/include/linux/mfd/pmic-lorix.h
@@ -6,48 +6,48 @@
 #include <linux/leds.h>
 
 struct attiny {
-	struct device *dev;
-	struct i2c_client *client;
+    struct device *dev;
+    struct i2c_client *client;
 
-	struct mutex lock;
+    struct mutex lock;
 
-	unsigned long id;
-	uint8_t mode;
+    unsigned long id;
+    uint8_t mode;
 };
 
 /*
  * LEDs subdevice platform data
  */
 struct attiny_led_platform_data {
-	int id;
-	const char *name;
-	const char *default_trigger;
+    int id;
+    const char *name;
+    const char *default_trigger;
 };
 
-#define MAX_LED_CONTROL_REGS	1
+#define MAX_LED_CONTROL_REGS    1
 
 struct attiny_leds_platform_data {
-	struct attiny_led_platform_data *led;
-	int num_leds;
-	u32 led_control[MAX_LED_CONTROL_REGS];
+    struct attiny_led_platform_data *led;
+    int num_leds;
+    u32 led_control[MAX_LED_CONTROL_REGS];
 };
 
 /*
  * GPIOs subdevice bits and masks
  */
 struct lorix_gpio_platform_data {
-	unsigned gpio_start;
-	u8 gpio_en_mask;
-	u8 gpio_pullup_mask;
+    unsigned gpio_start;
+    u8 gpio_en_mask;
+    u8 gpio_pullup_mask;
 };
 
 /*
  * MFD chip platform data
  */
 struct attiny_platform_data {
-	unsigned int flags;
+    unsigned int flags;
 
-	struct attiny_leds_platform_data *leds;
+    struct attiny_leds_platform_data *leds;
 };
 
 /*
-- 
2.17.1

